
<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HavaDurumuX - Çevrimdışı Sürüm (Konsept)</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f4f7f9;
            color: #333;
            transition: background-color 0.3s, color 0.3s;
        }
        .container {
            max-width: 900px;
            margin: auto;
            background-color: #fff;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        header {
            text-align: center;
            margin-bottom: 25px;
            border-bottom: 1px solid #e0e0e0;
            padding-bottom: 15px;
        }
        header h1 {
            color: #2c3e50;
            margin: 0;
        }
        header p {
            font-size: 0.9em;
            color: #7f8c8d;
        }
        select, button {
            padding: 10px 15px;
            margin-top: 5px;
            margin-bottom: 15px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 1em;
            cursor: pointer;
            background-color: #fff;
        }
        button {
            background-color: #3498db;
            color: white;
            border-color: #3498db;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #2980b9;
        }
        button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }
        .status-bar {
            padding: 10px;
            margin-bottom: 15px;
            border-radius: 5px;
            font-size: 0.9em;
            text-align: center;
        }
        .status-bar.success { background-color: #e8f5e9; color: #2e7d32; }
        .status-bar.error { background-color: #ffebee; color: #c62828; }
        .status-bar.info { background-color: #e3f2fd; color: #1565c0; }

        .weather-section {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f9f9f9;
            border: 1px solid #eee;
            border-radius: 8px;
        }
        .weather-section h2 {
            margin-top: 0;
            color: #34495e;
            font-size: 1.3em;
            border-bottom: 1px solid #eaeaea;
            padding-bottom: 8px;
        }
        .current-weather { text-align: center; }
        .current-weather .temp { font-size: 3em; font-weight: bold; color: #2c3e50; }
        .current-weather .desc { font-size: 1.1em; color: #555; margin-bottom: 10px; }
        .current-weather-details p { margin: 5px 0; font-size: 0.95em; }

        .forecast-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 10px;
        }
        .forecast-item {
            background-color: #fff;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            font-size: 0.85em;
            text-align: center;
        }
        .forecast-item .time { font-weight: bold; }
        .forecast-item .temp { color: #e67e22; }
        .forecast-item .precip { color: #3498db; }

        .chart-container {
            margin-top: 15px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #fff;
        }
        .chart-title { font-size: 0.9em; font-weight: bold; margin-bottom: 8px; text-align: center; }
        .svg-chart { display: block; margin: auto; }
        .svg-chart rect { transition: height 0.3s ease-out; }
        .svg-chart text { font-size: 10px; fill: #555; }
        
        .dark-mode {
            background-color: #2c3e50;
            color: #ecf0f1;
        }
        .dark-mode .container {
            background-color: #34495e;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        .dark-mode header h1 { color: #ecf0f1; }
        .dark-mode header p { color: #bdc3c7; }
        .dark-mode select, .dark-mode button {
            background-color: #566573;
            color: #ecf0f1;
            border-color: #707B7C;
        }
        .dark-mode button { background-color: #3498db; border-color: #3498db; }
        .dark-mode button:hover { background-color: #2980b9; }
        .dark-mode button:disabled { background-color: #7f8c8d; }
        
        .dark-mode .weather-section { background-color: #2c3e50; border-color: #4a6572; }
        .dark-mode .weather-section h2 { color: #ecf0f1; border-bottom-color: #4a6572; }
        .dark-mode .current-weather .temp { color: #ecf0f1; }
        .dark-mode .current-weather .desc { color: #bdc3c7; }
        .dark-mode .forecast-item { background-color: #34495e; box-shadow: 0 2px 5px rgba(0,0,0,0.15); color: #ecf0f1; }
        .dark-mode .forecast-item .temp { color: #f39c12; }
        .dark-mode .forecast-item .precip { color: #5dade2; }
        .dark-mode .chart-container { background-color: #2c3e50; border-color: #4a6572;}
        .dark-mode .svg-chart text { fill: #bdc3c7; }
        .dark-mode .status-bar.success { background-color: #1e4620; color: #a5d6a7; }
        .dark-mode .status-bar.error { background-color: #5e0000; color: #ef9a9a; }
        .dark-mode .status-bar.info { background-color: #0d47a1; color: #90caf9; }

        .icon-small { width: 24px; height: 24px; vertical-align: middle; margin-right: 5px; }
        .warning {
            background-color: #fff3cd;
            color: #856404;
            padding: 15px;
            border: 1px solid #ffeeba;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .footer-note {
            text-align: center; font-size: 0.8em; color: #7f8c8d; margin-top: 20px;
        }
        .dark-mode .footer-note { color: #bdc3c7; }

    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>HavaDurumuX - Çevrimdışı Sürüm</h1>
            <p>Bu sürüm, temel hava durumu bilgilerini internet bağlantısı olmadan sunmayı hedefler. Veriler periyodik olarak güncellenir.</p>
            <button id="toggleDarkMode">Koyu Modu Aç/Kapat</button>
        </header>

        <div class="warning">
            <strong>ÖNEMLİ NOT:</strong> Bu çevrimdışı sürüm bir konsept kanıtıdır.
            Doğru hava durumu verileri için illerin/ilçelerin coğrafi koordinatlarının (`lat`, `lon`) aşağıdaki JavaScript kodunda yer alan `provinceLocationData` dizisi içinde **doğru ve eksiksiz** olarak tanımlanması **kritik önem taşımaktadır**. Birçok ilçe için varsayılan olarak 0.0, 0.0 atanmıştır, bu da API'nin doğru veri döndürmesini engelleyecektir. Lütfen bu koordinatları güncelleyiniz.
        </div>

        <select id="provinceSelect"></select>
        <button id="updateAllDataButton">Tüm İllerin Verilerini Yenile (Yaklaşık 2-3 dk sürebilir)</button>
        <button id="clearLocalDataButton" style="background-color: #e74c3c;">Yerel Verileri Temizle</button>
        
        <div id="statusBar" class="status-bar">Durum mesajları burada gösterilecek.</div>
        <div id="lastUpdateTime" style="font-size: 0.8em; text-align: center; margin-bottom: 15px;"></div>

        <div id="weatherDisplay" style="display: none;">
            <div class="weather-section current-weather">
                <h2 id="currentLocationName"></h2>
                <p id="currentWeatherTime" style="font-size:0.9em;"></p>
                <div id="currentWeatherIcon" style="margin: 10px 0;"></div>
                <div id="currentTemperature" class="temp">--°C</div>
                <p id="currentWeatherDescription" class="desc">--</p>
                <div class="current-weather-details">
                    <p>Hissedilen: <span id="currentApparentTemperature">--</span>°C</p>
                    <p>Nem: <span id="currentHumidity">--</span>%</p>
                    <p>Rüzgar: <span id="currentWindSpeed">--</span> km/s (<span id="currentWindDirection">--</span>)</p>
                    <p>Rüzgar Hamlesi: <span id="currentWindGusts">--</span> km/s</p>
                    <p>Basınç: <span id="currentPressure">--</span> hPa</p>
                    <p>Görüş Mesafesi: <span id="currentVisibility">--</span> km</p>
                    <p>UV İndeksi: <span id="currentUvIndex">--</span></p>
                    <p>Yağış (1sa): <span id="currentPrecipitation">--</span> mm</p>
                </div>
            </div>

            <div class="weather-section">
                <h2>Saatlik Tahmin (İlk 24 Saat)</h2>
                <div id="hourlyForecast" class="forecast-grid"></div>
                <div class="chart-container">
                    <p class="chart-title">Saatlik Sıcaklık Değişimi (°C)</p>
                    <svg id="hourlyTempChart" class="svg-chart" width="100%" height="150"></svg>
                </div>
                <div class="chart-container">
                    <p class="chart-title">Saatlik Yağış İhtimali (%)</p>
                    <svg id="hourlyPrecipChart" class="svg-chart" width="100%" height="150"></svg>
                </div>
            </div>

            <div class="weather-section">
                <h2>Günlük Tahmin (7 Gün)</h2>
                <div id="dailyForecast" class="forecast-grid" style="grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));"></div>
            </div>
        </div>
         <div class="footer-note">
            Hava durumu verileri MET Norway (yr.no) ve Open-Meteo API'lerinden sağlanmaktadır.
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const MET_API_BASE_URL = 'https://api.met.no/weatherapi/locationforecast/2.0/compact';
        const OPEN_METEO_API_BASE_URL = 'https://api.open-meteo.com/v1/forecast';
        const USER_AGENT = 'HavaDurumuXOffline/1.0 (havadurumuxsite@gmail.com)';
        const BULK_UPDATE_INTERVAL_MS = 6 * 60 * 60 * 1000; // 6 hours
        const REQUEST_DELAY_MS = 2000; // 2 seconds between requests during bulk update
        const M_S_TO_KM_H = 3.6; // Conversion factor for m/s to km/h

        // --- LOCATION DATA (Merkez İlçeler) ---
        // !!! ÖNEMLİ: Aşağıdaki lat ve lon değerleri çoğunlukla 0.0, 0.0'dır.
        // !!! Doğru hava durumu için bu koordinatların GÜNCELLENMESİ GEREKİR!
        const turkeyLocationsRaw = {
          "Adana": [{ "name": "Merkez", "lat": 37.00, "lon": 35.32 }], // Örnek: Adana Merkez koordinatları
          "Adıyaman": [{ "name": "Merkez", "lat": 37.76, "lon": 38.27 }],
          "Afyonkarahisar": [{ "name": "Merkez", "lat": 38.75, "lon": 30.53 }],
          "Ağrı": [{ "name": "Merkez", "lat": 39.72, "lon": 43.05 }],
          "Aksaray": [{ "name": "Merkez", "lat": 38.37, "lon": 34.03 }],
          "Amasya": [{ "name": "Merkez", "lat": 40.65, "lon": 35.83 }],
          "Ankara": [{ "name": "Çankaya", "lat": 39.92, "lon": 32.85 }], // JSON'dan
          "Antalya": [{ "name": "Muratpaşa", "lat": 36.89, "lon": 30.70 }], // JSON'dan
          "Ardahan": [{ "name": "Merkez", "lat": 41.11, "lon": 42.70 }],
          "Artvin": [{ "name": "Merkez", "lat": 41.18, "lon": 41.82 }],
          "Aydın": [{ "name": "Efeler", "lat": 37.84, "lon": 27.84 }], // Efeler, Aydın merkez
          "Balıkesir": [{ "name": "Karesi", "lat": 39.65, "lon": 27.88 }], // Karesi, Balıkesir merkez
          "Bartın": [{ "name": "Merkez", "lat": 41.63, "lon": 32.33 }],
          "Batman": [{ "name": "Merkez", "lat": 37.88, "lon": 41.13 }],
          "Bayburt": [{ "name": "Merkez", "lat": 40.25, "lon": 40.22 }],
          "Bilecik": [{ "name": "Merkez", "lat": 40.14, "lon": 29.98 }],
          "Bingöl": [{ "name": "Merkez", "lat": 38.88, "lon": 40.49 }],
          "Bitlis": [{ "name": "Merkez", "lat": 38.40, "lon": 42.11 }],
          "Bolu": [{ "name": "Merkez", "lat": 40.73, "lon": 31.60 }],
          "Burdur": [{ "name": "Merkez", "lat": 37.72, "lon": 30.28 }],
          "Bursa": [{ "name": "Osmangazi", "lat": 40.19, "lon": 29.06 }], // Osmangazi, Bursa merkez
          "Çanakkale": [{ "name": "Merkez", "lat": 40.15, "lon": 26.41 }],
          "Çankırı": [{ "name": "Merkez", "lat": 40.60, "lon": 33.61 }],
          "Çorum": [{ "name": "Merkez", "lat": 40.55, "lon": 34.95 }],
          "Denizli": [{ "name": "Merkezefendi", "lat": 37.78, "lon": 29.09 }], // Merkezefendi, Denizli merkez
          "Diyarbakır": [{ "name": "Sur", "lat": 37.91, "lon": 40.23 }], // Sur, Diyarbakır merkez
          "Düzce": [{ "name": "Merkez", "lat": 40.84, "lon": 31.15 }],
          "Edirne": [{ "name": "Merkez", "lat": 41.67, "lon": 26.57 }],
          "Elazığ": [{ "name": "Merkez", "lat": 38.67, "lon": 39.22 }],
          "Erzincan": [{ "name": "Merkez", "lat": 39.74, "lon": 39.49 }],
          "Erzurum": [{ "name": "Yakutiye", "lat": 39.90, "lon": 41.27 }], // Yakutiye, Erzurum merkez
          "Eskişehir": [{ "name": "Odunpazarı", "lat": 39.77, "lon": 30.52 }], // Odunpazarı, Eskişehir merkez
          "Gaziantep": [{ "name": "Şahinbey", "lat": 37.06, "lon": 37.37 }], // Şahinbey, Gaziantep merkez
          "Giresun": [{ "name": "Merkez", "lat": 40.91, "lon": 38.39 }],
          "Gümüşhane": [{ "name": "Merkez", "lat": 40.46, "lon": 39.48 }],
          "Hakkari": [{ "name": "Merkez", "lat": 37.57, "lon": 43.74 }],
          "Hatay": [{ "name": "Antakya", "lat": 36.20, "lon": 36.16 }], // Antakya, Hatay merkez
          "Iğdır": [{ "name": "Merkez", "lat": 39.92, "lon": 44.04 }],
          "Isparta": [{ "name": "Merkez", "lat": 37.76, "lon": 30.55 }],
          "İstanbul": [{ "name": "Kadıköy", "lat": 40.99, "lon": 29.02 }], // JSON'dan
          "İzmir": [{ "name": "Konak", "lat": 38.42, "lon": 27.14 }], // JSON'dan
          "Kahramanmaraş": [{ "name": "Onikişubat", "lat": 37.57, "lon": 36.92 }], // Onikişubat, K.Maraş merkez
          "Karabük": [{ "name": "Merkez", "lat": 41.20, "lon": 32.62 }],
          "Karaman": [{ "name": "Merkez", "lat": 37.18, "lon": 33.21 }],
          "Kars": [{ "name": "Merkez", "lat": 40.60, "lon": 43.09 }],
          "Kastamonu": [{ "name": "Merkez", "lat": 41.37, "lon": 33.77 }],
          "Kayseri": [{ "name": "Melikgazi", "lat": 38.72, "lon": 35.48 }], // Melikgazi, Kayseri merkez
          "Kilis": [{ "name": "Merkez", "lat": 36.71, "lon": 37.11 }],
          "Kırıkkale": [{ "name": "Merkez", "lat": 39.84, "lon": 33.51 }],
          "Kırklareli": [{ "name": "Merkez", "lat": 41.73, "lon": 27.22 }],
          "Kırşehir": [{ "name": "Merkez", "lat": 39.14, "lon": 34.16 }],
          "Kocaeli": [{ "name": "İzmit", "lat": 40.76, "lon": 29.91 }], // İzmit, Kocaeli merkez
          "Konya": [{ "name": "Selçuklu", "lat": 37.87, "lon": 32.49 }], // Selçuklu, Konya merkez
          "Kütahya": [{ "name": "Merkez", "lat": 39.42, "lon": 29.98 }],
          "Malatya": [{ "name": "Yeşilyurt", "lat": 38.35, "lon": 38.30 }], // Yeşilyurt, Malatya merkez
          "Manisa": [{ "name": "Şehzadeler", "lat": 38.61, "lon": 27.42 }], // Şehzadeler, Manisa merkez
          "Mardin": [{ "name": "Artuklu", "lat": 37.31, "lon": 40.73 }], // Artuklu, Mardin merkez
          "Mersin": [{ "name": "Akdeniz", "lat": 36.80, "lon": 34.63 }], // Akdeniz, Mersin merkez
          "Muğla": [{ "name": "Menteşe", "lat": 37.21, "lon": 28.36 }], // Menteşe, Muğla merkez
          "Muş": [{ "name": "Merkez", "lat": 38.73, "lon": 41.49 }],
          "Nevşehir": [{ "name": "Merkez", "lat": 38.62, "lon": 34.71 }],
          "Niğde": [{ "name": "Merkez", "lat": 37.96, "lon": 34.67 }],
          "Ordu": [{ "name": "Altınordu", "lat": 40.98, "lon": 37.87 }], // Altınordu, Ordu merkez
          "Osmaniye": [{ "name": "Merkez", "lat": 37.07, "lon": 36.24 }],
          "Rize": [{ "name": "Merkez", "lat": 41.02, "lon": 40.52 }],
          "Sakarya": [{ "name": "Adapazarı", "lat": 40.78, "lon": 30.40 }], // Adapazarı, Sakarya merkez
          "Samsun": [{ "name": "İlkadım", "lat": 41.28, "lon": 36.33 }], // İlkadım, Samsun merkez
          "Şanlıurfa": [{ "name": "Eyyübiye", "lat": 37.15, "lon": 38.79 }], // Eyyübiye, Şanlıurfa merkez
          "Siirt": [{ "name": "Merkez", "lat": 37.93, "lon": 41.94 }],
          "Sinop": [{ "name": "Merkez", "lat": 42.02, "lon": 35.15 }],
          "Şırnak": [{ "name": "Merkez", "lat": 37.51, "lon": 42.45 }],
          "Sivas": [{ "name": "Merkez", "lat": 39.75, "lon": 37.01 }],
          "Tekirdağ": [{ "name": "Süleymanpaşa", "lat": 40.97, "lon": 27.51 }], // Süleymanpaşa, Tekirdağ merkez
          "Tokat": [{ "name": "Merkez", "lat": 40.32, "lon": 36.55 }],
          "Trabzon": [{ "name": "Ortahisar", "lat": 41.00, "lon": 39.72 }], // Ortahisar, Trabzon merkez
          "Tunceli": [{ "name": "Merkez", "lat": 39.10, "lon": 39.54 }],
          "Uşak": [{ "name": "Merkez", "lat": 38.68, "lon": 29.40 }],
          "Van": [{ "name": "İpekyolu", "lat": 38.50, "lon": 43.37 }], // İpekyolu, Van merkez
          "Yalova": [{ "name": "Merkez", "lat": 40.65, "lon": 29.27 }],
          "Yozgat": [{ "name": "Merkez", "lat": 39.82, "lon": 34.81 }],
          "Zonguldak": [{ "name": "Merkez", "lat": 41.45, "lon": 31.79 }]
        };

        const provinceLocationData = Object.entries(turkeyLocationsRaw).map(([province, districts]) => {
            const merkezDistrict = districts.find(d => d.name.toLowerCase().includes("merkez") || d.name.toLowerCase().includes(province.toLowerCase()) || districts.length === 1);
            // Özel durumlar (JSON'dan gelen temsili merkezler)
            if (province === "Ankara") return { name: `${province} / Çankaya`, province: province, district: "Çankaya", lat: 39.92, lon: 32.85 };
            if (province === "İstanbul") return { name: `${province} / Kadıköy`, province: province, district: "Kadıköy", lat: 40.99, lon: 29.02 };
            if (province === "İzmir") return { name: `${province} / Konak`, province: province, district: "Konak", lat: 38.42, lon: 27.14 };
            if (province === "Antalya") return { name: `${province} / Muratpaşa`, province: province, district: "Muratpaşa", lat: 36.89, lon: 30.70 };

            if (merkezDistrict) {
                return { name: `${province} / ${merkezDistrict.name}`, province: province, district: merkezDistrict.name, lat: merkezDistrict.lat, lon: merkezDistrict.lon };
            }
            // Eğer "Merkez" yoksa ve özel durum değilse, ilk ilçeyi al (veya o ili atla)
            // Bu örnekte, eğer "Merkez" yoksa ve özel bir durum değilse, o ili atlayacağız.
            // Veya JSON dosyanızda her il için temsili bir "merkez ilçe" olduğundan emin olmalısınız.
            // Bu prototip için, koordinatları 0 olanlar da listeye eklenecek ama uyarı gösterilecek.
            const firstDistrict = districts[0];
            if(firstDistrict) {
                 return { name: `${province} / ${firstDistrict.name} (Merkez Değil/Belirsiz)`, province: province, district: firstDistrict.name, lat: firstDistrict.lat, lon: firstDistrict.lon };
            }
            return null;

        }).filter(p => p !== null).sort((a, b) => a.province.localeCompare(b.province, 'tr'));


        // --- DOM ELEMENTS ---
        const provinceSelect = document.getElementById('provinceSelect');
        const updateAllDataButton = document.getElementById('updateAllDataButton');
        const clearLocalDataButton = document.getElementById('clearLocalDataButton');
        const statusBar = document.getElementById('statusBar');
        const lastUpdateTimeEl = document.getElementById('lastUpdateTime');
        const weatherDisplay = document.getElementById('weatherDisplay');
        const currentLocationNameEl = document.getElementById('currentLocationName');
        const currentWeatherTimeEl = document.getElementById('currentWeatherTime');
        const currentWeatherIconEl = document.getElementById('currentWeatherIcon');
        const currentTemperatureEl = document.getElementById('currentTemperature');
        const currentWeatherDescriptionEl = document.getElementById('currentWeatherDescription');
        const currentApparentTemperatureEl = document.getElementById('currentApparentTemperature');
        const currentHumidityEl = document.getElementById('currentHumidity');
        const currentWindSpeedEl = document.getElementById('currentWindSpeed');
        const currentWindDirectionEl = document.getElementById('currentWindDirection');
        const currentWindGustsEl = document.getElementById('currentWindGusts');
        const currentPressureEl = document.getElementById('currentPressure');
        const currentVisibilityEl = document.getElementById('currentVisibility');
        const currentUvIndexEl = document.getElementById('currentUvIndex');
        const currentPrecipitationEl = document.getElementById('currentPrecipitation');
        const hourlyForecastEl = document.getElementById('hourlyForecast');
        const dailyForecastEl = document.getElementById('dailyForecast');
        const hourlyTempChartEl = document.getElementById('hourlyTempChart');
        const hourlyPrecipChartEl = document.getElementById('hourlyPrecipChart');
        const toggleDarkModeButton = document.getElementById('toggleDarkMode');

        // --- STATE ---
        let currentSelectedProvinceKey = null;
        let temperatureAnimationInterval = null;

        // --- WEATHER ICON MAPPING (Simplified) ---
        const weatherCodeMap = {
            0: { description: 'Açık', icon: '☀️' }, 1: { description: 'Parçalı Bulutlu', icon: '🌤️' },
            2: { description: 'Bulutlu', icon: '☁️' }, 3: { description: 'Çok Bulutlu', icon: '🌥️' },
            45: { description: 'Sisli', icon: '🌫️' }, 48: { description: 'Kırağı Sisi', icon: '🌫️' },
            51: { description: 'Hafif Çisenti', icon: '🌦️' }, 53: { description: 'Orta Çisenti', icon: '🌦️' },
            55: { description: 'Yoğun Çisenti', icon: '🌧️' }, 56: { description: 'Hafif Donan Çisenti', icon: '🌨️' },
            57: { description: 'Yoğun Donan Çisenti', icon: '🌨️' }, 61: { description: 'Hafif Yağmurlu', icon: '🌧️' },
            63: { description: 'Orta Yağmurlu', icon: '🌧️' }, 65: { description: 'Şiddetli Yağmurlu', icon: '🌧️' },
            66: { description: 'Hafif Donan Yağmur', icon: '🌨️' }, 67: { description: 'Yoğun Donan Yağmur', icon: '🌨️' },
            71: { description: 'Hafif Kar', icon: '🌨️' }, 73: { description: 'Orta Kar', icon: '❄️' },
            75: { description: 'Yoğun Kar', icon: '❄️' }, 77: { description: 'Kar Taneleri', icon: '❄️' },
            80: { description: 'Hafif Sağanak', icon: '🌦️' }, 81: { description: 'Orta Sağanak', icon: '🌧️' },
            82: { description: 'Şiddetli Sağanak', icon: '⛈️' }, 85: { description: 'Hafif Kar Sağanağı', icon: '🌨️' },
            86: { description: 'Yoğun Kar Sağanağı', icon: '❄️' }, 95: { description: 'Gök Gürültülü Fırtına', icon: '⛈️' },
            96: { description: 'Hafif Dolu ile Fırtına', icon: '⛈️🧊' }, 99: { description: 'Yoğun Dolu ile Fırtına', icon: '⛈️🧊' }
        };

        function getWeatherInfo(code, isDay = true) {
            const info = weatherCodeMap[code];
            if (info) {
                if (code === 0 && !isDay) return { description: 'Açık (Gece)', icon: '🌙' };
                return info;
            }
            return { description: 'Bilinmiyor', icon: '❓' };
        }
        
        function getWindDirectionSymbol(degrees) {
            if (degrees === null || degrees === undefined) return 'N/A';
            const directions = ['K', 'KKD', 'KD', 'DKD', 'D', 'DGD', 'GD', 'GGD', 'G', 'GGB', 'GB', 'BGB', 'B', 'BKB', 'KB', 'KKB'];
            return directions[Math.round(degrees / 22.5) % 16];
        }

        // --- DARK MODE ---
        function applyDarkModePreference() {
            if (localStorage.getItem('havadurumux-offline-dark-mode') === 'true') {
                document.body.classList.add('dark-mode');
            } else {
                document.body.classList.remove('dark-mode');
            }
        }
        toggleDarkModeButton.addEventListener('click', () => {
            document.body.classList.toggle('dark-mode');
            localStorage.setItem('havadurumux-offline-dark-mode', document.body.classList.contains('dark-mode'));
        });

        // --- API SERVICE ---
        async function fetchWeatherDataFromMET(lat, lon) {
            const url = `${MET_API_BASE_URL}?lat=${lat}&lon=${lon}`;
            try {
                const response = await fetch(url, { headers: { 'User-Agent': USER_AGENT } });
                if (!response.ok) {
                    throw new Error(`MET API Error: ${response.status} ${response.statusText}`);
                }
                return await response.json();
            } catch (error) {
                console.error("Error fetching from MET API:", error);
                throw error;
            }
        }
        
        async function fetchWeatherDataFromOpenMeteo(lat, lon) {
            const params = new URLSearchParams({
                latitude: lat,
                longitude: lon,
                current: 'apparent_temperature,visibility,uv_index,wind_gusts_10m,precipitation,relative_humidity_2m,surface_pressure,cloud_cover',
                hourly: 'apparent_temperature,precipitation_probability,visibility,uv_index,wind_gusts_10m,soil_temperature_0cm,soil_moisture_0_1cm,pressure_msl,rain,showers,snowfall,cloud_cover',
                daily: 'sunrise,sunset,uv_index_max,precipitation_probability_max,wind_gusts_10m_max,apparent_temperature_max,apparent_temperature_min,rain_sum,showers_sum,snowfall_sum,precipitation_hours',
                forecast_days: 7, // Max forecast days matching MET, adjust if needed
                timezone: 'auto'
            });
            const url = `${OPEN_METEO_API_BASE_URL}?${params.toString()}`;
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`OpenMeteo API Error: ${response.status}`);
                }
                return await response.json();
            } catch (error) {
                console.error("Error fetching from OpenMeteo API:", error);
                return null; // Return null if OpenMeteo fails, MET data will still be used
            }
        }


        function processWeatherData(metData, openMeteoData, provinceKey) {
            if (!metData || !metData.properties || !metData.properties.timeseries) {
                console.error("Invalid MET data structure for", provinceKey, metData);
                return null;
            }
            const timeseries = metData.properties.timeseries;
            const forecastUntil = new Date();
            forecastUntil.setHours(forecastUntil.getHours() + 66);

            const relevantTimeseries = timeseries.filter(ts => new Date(ts.time) <= forecastUntil);

            const now = new Date();
            let currentDataPoint = relevantTimeseries.find(ts => new Date(ts.time) >= now) || relevantTimeseries[relevantTimeseries.length - 1];
             if (!currentDataPoint && relevantTimeseries.length > 0) { // Fallback to latest if no future point
                currentDataPoint = relevantTimeseries[relevantTimeseries.length -1];
             }


            const omCurrent = openMeteoData?.current || {};
            const omHourly = openMeteoData?.hourly || {};
            const omDaily = openMeteoData?.daily || {};

            const current = {
                time: currentDataPoint.time,
                temperature_2m: currentDataPoint.data.instant.details.air_temperature,
                apparent_temperature: omCurrent.apparent_temperature ?? currentDataPoint.data.instant.details.air_temperature, // Fallback
                relative_humidity_2m: currentDataPoint.data.instant.details.relative_humidity,
                is_day: new Date(currentDataPoint.time).getHours() > 6 && new Date(currentDataPoint.time).getHours() < 20 ? 1:0, // Simple day check
                precipitation: omCurrent.precipitation ?? currentDataPoint.data.next_1_hours?.details?.precipitation_amount ?? 0,
                weather_code: getWeatherInfo(currentDataPoint.data.next_1_hours?.summary?.symbol_code || currentDataPoint.data.next_6_hours?.summary?.symbol_code).wmoCode || 0, // Simplified
                cloud_cover: omCurrent.cloud_cover ?? currentDataPoint.data.instant.details.cloud_area_fraction,
                surface_pressure: omCurrent.surface_pressure ?? currentDataPoint.data.instant.details.air_pressure_at_sea_level,
                wind_speed_10m: (currentDataPoint.data.instant.details.wind_speed * M_S_TO_KM_H).toFixed(1),
                wind_direction_10m: currentDataPoint.data.instant.details.wind_from_direction,
                wind_gusts_10m: omCurrent.wind_gusts_10m ? omCurrent.wind_gusts_10m.toFixed(1) : 'N/A',
                visibility: omCurrent.visibility ? (omCurrent.visibility / 1000).toFixed(1) : 'N/A',
                uv_index: omCurrent.uv_index ?? 'N/A',
            };

            const hourly = relevantTimeseries.map((ts, index) => {
                const omHourIndex = omHourly.time?.findIndex(omt => new Date(omt).getTime() === new Date(ts.time).getTime());
                const omHourData = omHourIndex !== -1 && omHourly.temperature_2m ? {
                    apparent_temperature: omHourly.apparent_temperature[omHourIndex],
                    precipitation_probability: omHourly.precipitation_probability[omHourIndex],
                    visibility: omHourly.visibility[omHourIndex],
                    uv_index: omHourly.uv_index[omHourIndex],
                    wind_gusts_10m: omHourly.wind_gusts_10m[omHourIndex],
                    cloud_cover: omHourly.cloud_cover[omHourIndex],
                    pressure_msl: omHourly.pressure_msl[omHourIndex],
                } : {};

                return {
                    time: ts.time,
                    temperature_2m: ts.data.instant.details.air_temperature,
                    apparent_temperature: omHourData.apparent_temperature ?? ts.data.instant.details.air_temperature,
                    relative_humidity_2m: ts.data.instant.details.relative_humidity,
                    precipitation_probability: omHourData.precipitation_probability ?? 0, // default 0 if not from OM
                    precipitation: ts.data.next_1_hours?.details?.precipitation_amount ?? 0,
                    weather_code: getWeatherInfo(ts.data.next_1_hours?.summary?.symbol_code || ts.data.next_6_hours?.summary?.symbol_code).wmoCode || 0,
                    wind_speed_10m: (ts.data.instant.details.wind_speed * M_S_TO_KM_H),
                    wind_direction_10m: ts.data.instant.details.wind_from_direction,
                    wind_gusts_10m: omHourData.wind_gusts_10m,
                    cloud_cover: omHourData.cloud_cover ?? ts.data.instant.details.cloud_area_fraction,
                    pressure_msl: omHourData.pressure_msl ?? ts.data.instant.details.air_pressure_at_sea_level,
                };
            });

            const daily = [];
            if(omDaily.time && omDaily.time.length > 0) {
                for (let i = 0; i < Math.min(omDaily.time.length, 7); i++) {
                    daily.push({
                        time: omDaily.time[i],
                        weather_code: omDaily.weather_code ? omDaily.weather_code[i] : getWeatherInfo(hourly.find(h => h.time.startsWith(omDaily.time[i]))?.weather_code).wmoCode || 0, // Fallback
                        temperature_2m_max: omDaily.temperature_2m_max ? omDaily.temperature_2m_max[i] : null,
                        temperature_2m_min: omDaily.temperature_2m_min ? omDaily.temperature_2m_min[i] : null,
                        apparent_temperature_max: omDaily.apparent_temperature_max ? omDaily.apparent_temperature_max[i] : null,
                        apparent_temperature_min: omDaily.apparent_temperature_min ? omDaily.apparent_temperature_min[i] : null,
                        sunrise: omDaily.sunrise ? omDaily.sunrise[i] : null,
                        sunset: omDaily.sunset ? omDaily.sunset[i] : null,
                        uv_index_max: omDaily.uv_index_max ? omDaily.uv_index_max[i] : null,
                        precipitation_sum: omDaily.precipitation_sum ? omDaily.precipitation_sum[i] : null,
                        precipitation_probability_max: omDaily.precipitation_probability_max ? omDaily.precipitation_probability_max[i] : null,
                        wind_gusts_10m_max: omDaily.wind_gusts_10m_max ? omDaily.wind_gusts_10m_max[i] : null,
                        rain_sum: omDaily.rain_sum ? omDaily.rain_sum[i] : null,
                        showers_sum: omDaily.showers_sum ? omDaily.showers_sum[i] : null,
                        snowfall_sum: omDaily.snowfall_sum ? omDaily.snowfall_sum[i] : null,
                        precipitation_hours: omDaily.precipitation_hours ? omDaily.precipitation_hours[i] : null,
                    });
                }
            } else { // Fallback if OpenMeteo daily fails, derive from MET hourly
                const dailyAggregated = {};
                hourly.forEach(h => {
                    const day = h.time.split('T')[0];
                    if (!dailyAggregated[day]) {
                        dailyAggregated[day] = {
                            temps: [], precips: [], codes: [], windSpeeds: [], gusts: []
                        };
                    }
                    dailyAggregated[day].temps.push(h.temperature_2m);
                    dailyAggregated[day].precips.push(h.precipitation);
                    dailyAggregated[day].codes.push(h.weather_code);
                    dailyAggregated[day].windSpeeds.push(h.wind_speed_10m);
                    if(h.wind_gusts_10m) dailyAggregated[day].gusts.push(h.wind_gusts_10m);

                });

                Object.keys(dailyAggregated).slice(0, 7).forEach(dayKey => {
                    const dayData = dailyAggregated[dayKey];
                    const dominantCode = dayData.codes.sort((a,b) => dayData.codes.filter(v => v===a).length - dayData.codes.filter(v => v===b).length).pop();
                    daily.push({
                        time: dayKey,
                        weather_code: dominantCode,
                        temperature_2m_max: Math.max(...dayData.temps),
                        temperature_2m_min: Math.min(...dayData.temps),
                        precipitation_sum: dayData.precips.reduce((a,b) => a+b, 0),
                        // ... (sunrise/sunset etc. would still be missing here)
                    });
                });
            }


            return {
                latitude: metData.geometry.coordinates[1],
                longitude: metData.geometry.coordinates[0],
                current,
                hourly,
                daily,
                fetchedAt: new Date().toISOString()
            };
        }


        // --- LOCALSTORAGE SERVICE ---
        function saveDataToLocalStorage(provinceKey, data) {
            try {
                localStorage.setItem(`offline_weather_${provinceKey}`, JSON.stringify(data));
            } catch (e) {
                console.error("Error saving to localStorage (quota likely exceeded):", e);
                updateStatus("Yerel depolama dolu, eski veriler gösteriliyor olabilir.", true);
            }
        }

        function loadDataFromLocalStorage(provinceKey) {
            const data = localStorage.getItem(`offline_weather_${provinceKey}`);
            return data ? JSON.parse(data) : null;
        }

        function getLastBulkUpdateTime() {
            return localStorage.getItem('offline_lastBulkUpdateTime');
        }

        function setLastBulkUpdateTime() {
            localStorage.setItem('offline_lastBulkUpdateTime', new Date().toISOString());
        }
        
        clearLocalDataButton.addEventListener('click', () => {
            if (confirm("Tüm kaydedilmiş hava durumu verilerini silmek istediğinizden emin misiniz?")) {
                provinceLocationData.forEach(pData => {
                    localStorage.removeItem(`offline_weather_${pData.province}_${pData.district}`);
                });
                localStorage.removeItem('offline_lastBulkUpdateTime');
                localStorage.removeItem('offline_selectedProvinceKey');
                updateStatus("Tüm yerel veriler silindi.", false);
                weatherDisplay.style.display = 'none';
                lastUpdateTimeEl.textContent = 'Son Güncelleme: Henüz yok';
                currentSelectedProvinceKey = provinceLocationData[0]?.name; // Reset to first province
                if (provinceSelect.options.length > 0) provinceSelect.value = currentSelectedProvinceKey;
                checkAndLoadDataForProvince(currentSelectedProvinceKey);
            }
        });

        // --- UI SERVICE ---
        function updateStatus(message, isError = false) {
            statusBar.textContent = message;
            statusBar.className = 'status-bar'; // Reset
            if (isError) statusBar.classList.add('error');
            else statusBar.classList.add('info');
        }

        function displayWeatherData(data, locationDisplayName) {
            if (!data) {
                updateStatus(`${locationDisplayName} için hava durumu verisi bulunamadı.`, true);
                weatherDisplay.style.display = 'none';
                return;
            }
            weatherDisplay.style.display = 'block';
            updateStatus(`${locationDisplayName} için hava durumu gösteriliyor. Son API Çekme: ${new Date(data.fetchedAt).toLocaleString('tr-TR')}`, false);

            // Current Weather
            const { current, hourly, daily } = data;
            currentLocationNameEl.textContent = locationDisplayName;
            currentWeatherTimeEl.textContent = `Tahmin Zamanı: ${new Date(current.time).toLocaleString('tr-TR', { weekday: 'long', hour: '2-digit', minute: '2-digit' })}`;
            
            const currentWInfo = getWeatherInfo(current.weather_code, current.is_day);
            currentWeatherIconEl.innerHTML = `<span style="font-size: 3em;" title="${currentWInfo.description}">${currentWInfo.icon}</span>`;
            currentWeatherDescriptionEl.textContent = currentWInfo.description;

            // Kademeli sıcaklık
            if (temperatureAnimationInterval) clearInterval(temperatureAnimationInterval);
            let displayTemp = parseFloat(current.temperature_2m);
            currentTemperatureEl.textContent = `${displayTemp.toFixed(1)}°C`;

            const currentHourIndex = hourly.findIndex(h => new Date(h.time) >= new Date(current.time));
            const nextHourData = hourly[currentHourIndex + 1];

            if (nextHourData) {
                const tempDiff = parseFloat(nextHourData.temperature_2m) - displayTemp;
                const steps = 60 * 2; // 2 steps per minute for an hour transition (adjust for smoother/faster)
                const increment = tempDiff / steps;
                let currentStep = 0;
                temperatureAnimationInterval = setInterval(() => {
                    if (currentStep < steps) {
                        displayTemp += increment;
                        currentTemperatureEl.textContent = `${displayTemp.toFixed(1)}°C`;
                        currentStep++;
                    } else {
                        clearInterval(temperatureAnimationInterval);
                        currentTemperatureEl.textContent = `${parseFloat(nextHourData.temperature_2m).toFixed(1)}°C`; // Ensure final value
                    }
                }, 30000 / steps); // Total 30 seconds for transition (adjust as needed)
            }


            currentApparentTemperatureEl.textContent = current.apparent_temperature?.toFixed(1) ?? 'N/A';
            currentHumidityEl.textContent = current.relative_humidity_2m?.toFixed(0) ?? 'N/A';
            currentWindSpeedEl.textContent = current.wind_speed_10m ?? 'N/A';
            currentWindDirectionEl.textContent = getWindDirectionSymbol(current.wind_direction_10m);
            currentWindGustsEl.textContent = current.wind_gusts_10m ?? 'N/A';
            currentPressureEl.textContent = current.surface_pressure?.toFixed(0) ?? 'N/A';
            currentVisibilityEl.textContent = current.visibility ?? 'N/A';
            currentUvIndexEl.textContent = current.uv_index ?? 'N/A';
            currentPrecipitationEl.textContent = current.precipitation?.toFixed(1) ?? 'N/A';


            // Hourly Forecast
            hourlyForecastEl.innerHTML = ''; // Clear previous
            hourly.slice(0, 24).forEach(hour => {
                const hourEl = document.createElement('div');
                hourEl.classList.add('forecast-item');
                const hourTime = new Date(hour.time);
                const wInfo = getWeatherInfo(hour.weather_code, hourTime.getHours() > 6 && hourTime.getHours() < 20);
                hourEl.innerHTML = `
                    <div class="time">${hourTime.toLocaleTimeString('tr-TR', { hour: '2-digit', minute: '2-digit' })}</div>
                    <div style="font-size: 1.5em;" title="${wInfo.description}">${wInfo.icon}</div>
                    <div class="temp">${hour.temperature_2m?.toFixed(1) ?? 'N/A'}°C</div>
                    <div class="desc" style="font-size:0.8em;">${wInfo.description}</div>
                    <div class="precip" title="Yağış İhtimali">💧 ${hour.precipitation_probability?.toFixed(0) ?? 'N/A'}%</div>
                    <div class="precip" title="Yağış Miktarı">☔ ${hour.precipitation?.toFixed(1) ?? 'N/A'}mm</div>
                `;
                hourlyForecastEl.appendChild(hourEl);
            });
            
            // Daily Forecast
            dailyForecastEl.innerHTML = '';
            daily.forEach(day => {
                const dayEl = document.createElement('div');
                dayEl.classList.add('forecast-item');
                const date = new Date(day.time);
                const wInfo = getWeatherInfo(day.weather_code, true); // Assume day for daily icon
                dayEl.innerHTML = `
                    <div class="time">${date.toLocaleDateString('tr-TR', { weekday: 'short', day: 'numeric', month: 'short' })}</div>
                    <div style="font-size: 1.8em;" title="${wInfo.description}">${wInfo.icon}</div>
                    <div>${wInfo.description}</div>
                    <div class="temp">Max: ${day.temperature_2m_max?.toFixed(1) ?? 'N/A'}°C</div>
                    <div class="temp">Min: ${day.temperature_2m_min?.toFixed(1) ?? 'N/A'}°C</div>
                    <div class="precip" title="Yağış İhtimali">💧 ${day.precipitation_probability_max?.toFixed(0) ?? 'N/A'}%</div>
                    <div class="precip" title="Toplam Yağış">☔ ${day.precipitation_sum?.toFixed(1) ?? 'N/A'}mm</div>
                `;
                dailyForecastEl.appendChild(dayEl);
            });

            // Charts
            createBarChart(hourlyTempChartEl, hourly.slice(0, 24).map(h => ({ label: new Date(h.time).getHours() + ':00', value: h.temperature_2m })), 'Sıcaklık (°C)', '#e67e22');
            createBarChart(hourlyPrecipChartEl, hourly.slice(0, 24).map(h => ({ label: new Date(h.time).getHours() + ':00', value: h.precipitation_probability })), 'Yağış İhtimali (%)', '#3498db', 100);
        }

        function createBarChart(svgElement, data, unit, color, maxValue = null) {
            svgElement.innerHTML = ''; // Clear previous chart
            const chartWidth = svgElement.clientWidth || 300;
            const chartHeight = svgElement.clientHeight || 150;
            const barPadding = 5;
            const barWidth = (chartWidth - (data.length + 1) * barPadding) / data.length;
            
            const values = data.map(d => d.value === null || d.value === undefined ? 0 : d.value);
            const yMax = maxValue !== null ? maxValue : (Math.max(...values) > 0 ? Math.max(...values) : 10); // Ensure yMax is not 0
            const yMin = Math.min(...values) < 0 ? Math.min(...values) : 0; // Handle negative temps
            const yRange = yMax - yMin;

            data.forEach((d, i) => {
                const barHeight = yRange === 0 ? 0 : ((d.value - yMin) / yRange) * (chartHeight - 20); // -20 for labels
                const x = barPadding + i * (barWidth + barPadding);
                const y = chartHeight - 15 - barHeight; // -15 for x-axis labels

                const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                rect.setAttribute('x', x);
                rect.setAttribute('y', y);
                rect.setAttribute('width', barWidth);
                rect.setAttribute('height', Math.max(0, barHeight)); // Ensure non-negative height
                rect.setAttribute('fill', color);
                rect.setAttribute('rx', '3');
                rect.setAttribute('ry', '3');
                svgElement.appendChild(rect);

                const textLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
                textLabel.setAttribute('x', x + barWidth / 2);
                textLabel.setAttribute('y', chartHeight - 5);
                textLabel.setAttribute('text-anchor', 'middle');
                textLabel.textContent = d.label;
                svgElement.appendChild(textLabel);
                
                const textValue = document.createElementNS("http://www.w3.org/2000/svg", "text");
                textValue.setAttribute('x', x + barWidth / 2);
                textValue.setAttribute('y', y - 3);
                textValue.setAttribute('text-anchor', 'middle');
                textValue.setAttribute('font-size', '9px');
                textValue.textContent = d.value?.toFixed(0) + (unit.includes('%') ? '%' : '°');
                svgElement.appendChild(textValue);
            });
        }

        // --- APP LOGIC ---
        async function checkAndLoadDataForProvince(provinceKeyToLoad) {
            const location = provinceLocationData.find(p => p.name === provinceKeyToLoad);
            if (!location) {
                updateStatus(`Seçilen konum (${provinceKeyToLoad}) bulunamadı.`, true);
                return;
            }
            
            if (location.lat === 0.0 && location.lon === 0.0) {
                updateStatus(`${location.name} için geçerli koordinat bulunamadı. Lütfen HTML dosyasındaki koordinatları güncelleyin.`, true);
                 weatherDisplay.style.display = 'none';
                return;
            }

            let data = loadDataFromLocalStorage(`${location.province}_${location.district}`);
            const now = new Date().getTime();

            if (data && (now - new Date(data.fetchedAt).getTime()) < BULK_UPDATE_INTERVAL_MS) {
                updateStatus(`${location.name} için yerel veriler kullanılıyor.`, false);
                displayWeatherData(data, location.name);
            } else {
                updateStatus(`${location.name} için MET Norway ve OpenMeteo API'lerinden veri çekiliyor...`, false);
                try {
                    const metData = await fetchWeatherDataFromMET(location.lat, location.lon);
                    const openMeteoData = await fetchWeatherDataFromOpenMeteo(location.lat, location.lon);
                    
                    const processedData = processWeatherData(metData, openMeteoData, `${location.province}_${location.district}`);
                    if (processedData) {
                        saveDataToLocalStorage(`${location.province}_${location.district}`, processedData);
                        displayWeatherData(processedData, location.name);
                    } else {
                         updateStatus(`${location.name} için veri işlenemedi.`, true);
                    }
                } catch (error) {
                    updateStatus(`${location.name} için veri çekilemedi: ${error.message}. Yerel veri varsa o gösteriliyor.`, true);
                    if(data) displayWeatherData(data, location.name); // Show stale data if fetch fails
                    else weatherDisplay.style.display = 'none';
                }
            }
        }
        
        let isBulkUpdating = false;
        async function initiateBulkUpdate() {
            if (isBulkUpdating) {
                updateStatus("Toplu güncelleme zaten devam ediyor.", true);
                return;
            }
            isBulkUpdating = true;
            updateAllDataButton.disabled = true;
            updateStatus("Tüm iller için toplu veri güncelleme başlatıldı...", false);
            let successCount = 0;
            let errorCount = 0;

            for (let i = 0; i < provinceLocationData.length; i++) {
                const loc = provinceLocationData[i];
                if (loc.lat === 0.0 && loc.lon === 0.0) {
                    console.warn(`Skipping ${loc.name} due to 0.0 coordinates.`);
                    errorCount++;
                    updateStatus(`(${i+1}/${provinceLocationData.length}) ${loc.name} için koordinat yok, atlanıyor...`, true);
                    await new Promise(resolve => setTimeout(resolve, 50)); // Short delay for UI
                    continue;
                }

                updateStatus(`(${i+1}/${provinceLocationData.length}) ${loc.name} için veri çekiliyor...`, false);
                try {
                    const metData = await fetchWeatherDataFromMET(loc.lat, loc.lon);
                    const openMeteoData = await fetchWeatherDataFromOpenMeteo(loc.lat, loc.lon);
                    const processedData = processWeatherData(metData, openMeteoData, `${loc.province}_${loc.district}`);
                    
                    if (processedData) {
                        saveDataToLocalStorage(`${loc.province}_${loc.district}`, processedData);
                        successCount++;
                    } else {
                        errorCount++;
                    }
                } catch (error) {
                    console.error(`Error fetching for ${loc.name}:`, error);
                    errorCount++;
                }
                if (i < provinceLocationData.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, REQUEST_DELAY_MS));
                }
            }
            setLastBulkUpdateTime();
            updateStatus(`Toplu güncelleme tamamlandı. Başarılı: ${successCount}, Hatalı: ${errorCount}.`, false);
            lastUpdateTimeEl.textContent = `Tüm Veriler Son Güncelleme: ${new Date().toLocaleString('tr-TR')}`;
            // Reload data for current selection if it was part of the bulk update
            if (currentSelectedProvinceKey) {
                checkAndLoadDataForProvince(currentSelectedProvinceKey);
            }
            isBulkUpdating = false;
            updateAllDataButton.disabled = false;
        }

        function populateProvinces() {
            provinceLocationData.forEach(pData => {
                if(pData){ // Ensure pData is not null
                    const option = document.createElement('option');
                    option.value = pData.name; // Use combined name as value for simplicity
                    option.textContent = pData.name;
                    provinceSelect.appendChild(option);
                }
            });
        }

        provinceSelect.addEventListener('change', (event) => {
            currentSelectedProvinceKey = event.target.value;
            localStorage.setItem('offline_selectedProvinceKey', currentSelectedProvinceKey);
            if (temperatureAnimationInterval) clearInterval(temperatureAnimationInterval); // Clear animation on province change
            checkAndLoadDataForProvince(currentSelectedProvinceKey);
        });

        updateAllDataButton.addEventListener('click', initiateBulkUpdate);

        function initApp() {
            applyDarkModePreference();
            populateProvinces();
            
            const lastSelected = localStorage.getItem('offline_selectedProvinceKey');
            currentSelectedProvinceKey = lastSelected || (provinceLocationData[0] ? provinceLocationData[0].name : null);

            if (currentSelectedProvinceKey && provinceSelect.options.length > 0) {
                 // Check if the value exists in options
                let valueExists = false;
                for(let i=0; i < provinceSelect.options.length; i++){
                    if(provinceSelect.options[i].value === currentSelectedProvinceKey){
                        valueExists = true;
                        break;
                    }
                }
                if(valueExists) {
                    provinceSelect.value = currentSelectedProvinceKey;
                } else {
                     currentSelectedProvinceKey = provinceLocationData[0] ? provinceLocationData[0].name : null; // fallback to first
                     if(currentSelectedProvinceKey) provinceSelect.value = currentSelectedProvinceKey;
                }
            }


            const lastUpdateTimestamp = getLastBulkUpdateTime();
            if (lastUpdateTimestamp) {
                lastUpdateTimeEl.textContent = `Tüm Veriler Son Güncelleme: ${new Date(lastUpdateTimestamp).toLocaleString('tr-TR')}`;
                if (new Date().getTime() - new Date(lastUpdateTimestamp).getTime() > BULK_UPDATE_INTERVAL_MS) {
                    updateStatus("Veriler 6 saatten eski, toplu güncelleme önerilir.", false);
                    // Optionally, auto-trigger update if user preference allows (not implemented here)
                    // initiateBulkUpdate(); 
                } else {
                     if(currentSelectedProvinceKey) checkAndLoadDataForProvince(currentSelectedProvinceKey);
                }
            } else {
                lastUpdateTimeEl.textContent = 'Tüm Veriler Son Güncelleme: Henüz yok. Lütfen güncelleyin.';
                // First time load, prompt for update or auto-start
                updateStatus("İlk kullanım. Tüm il verilerini çekmek için 'Tüm İllerin Verilerini Yenile' butonuna tıklayın.", false);
                // initiateBulkUpdate(); // Optionally auto-start on first load
            }
            
            if(!lastUpdateTimestamp && provinceLocationData.length > 0 && currentSelectedProvinceKey) {
                 // If no bulk update ever, and there's a selected province, try to load its data.
                 // This handles the case where the user has never done a bulk update but selected a province.
                 checkAndLoadDataForProvince(currentSelectedProvinceKey);
            }


        }

        // --- INITIALIZATION ---
        document.addEventListener('DOMContentLoaded', initApp);

    </script>
</body>
</html>

    