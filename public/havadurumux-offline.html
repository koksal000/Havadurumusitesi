
<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HavaDurumuX - Ã‡evrimdÄ±ÅŸÄ± SÃ¼rÃ¼m (Konsept)</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f4f7f9;
            color: #333;
            transition: background-color 0.3s, color 0.3s;
        }
        .container {
            max-width: 900px;
            margin: auto;
            background-color: #fff;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        header {
            text-align: center;
            margin-bottom: 25px;
            border-bottom: 1px solid #e0e0e0;
            padding-bottom: 15px;
        }
        header h1 {
            color: #2c3e50;
            margin: 0;
        }
        header p {
            font-size: 0.9em;
            color: #7f8c8d;
        }
        select, button {
            padding: 10px 15px;
            margin-top: 5px;
            margin-bottom: 15px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 1em;
            cursor: pointer;
            background-color: #fff;
        }
        button {
            background-color: #3498db;
            color: white;
            border-color: #3498db;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #2980b9;
        }
        button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }
        .status-bar {
            padding: 10px;
            margin-bottom: 15px;
            border-radius: 5px;
            font-size: 0.9em;
            text-align: center;
        }
        .status-bar.success { background-color: #e8f5e9; color: #2e7d32; }
        .status-bar.error { background-color: #ffebee; color: #c62828; }
        .status-bar.info { background-color: #e3f2fd; color: #1565c0; }

        .weather-section {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f9f9f9;
            border: 1px solid #eee;
            border-radius: 8px;
        }
        .weather-section h2 {
            margin-top: 0;
            color: #34495e;
            font-size: 1.3em;
            border-bottom: 1px solid #eaeaea;
            padding-bottom: 8px;
        }
        .current-weather { text-align: center; }
        .current-weather .temp { font-size: 3em; font-weight: bold; color: #2c3e50; }
        .current-weather .desc { font-size: 1.1em; color: #555; margin-bottom: 10px; }
        .current-weather-details p { margin: 5px 0; font-size: 0.95em; }

        .forecast-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 10px;
        }
        .forecast-item {
            background-color: #fff;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            font-size: 0.85em;
            text-align: center;
        }
        .forecast-item .time { font-weight: bold; }
        .forecast-item .temp { color: #e67e22; }
        .forecast-item .precip { color: #3498db; }

        .chart-container {
            margin-top: 15px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #fff;
        }
        .chart-title { font-size: 0.9em; font-weight: bold; margin-bottom: 8px; text-align: center; }
        .svg-chart { display: block; margin: auto; }
        .svg-chart rect { transition: height 0.3s ease-out; }
        .svg-chart text { font-size: 10px; fill: #555; }
        
        .dark-mode {
            background-color: #2c3e50;
            color: #ecf0f1;
        }
        .dark-mode .container {
            background-color: #34495e;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        .dark-mode header h1 { color: #ecf0f1; }
        .dark-mode header p { color: #bdc3c7; }
        .dark-mode select, .dark-mode button {
            background-color: #566573;
            color: #ecf0f1;
            border-color: #707B7C;
        }
        .dark-mode button { background-color: #3498db; border-color: #3498db; }
        .dark-mode button:hover { background-color: #2980b9; }
        .dark-mode button:disabled { background-color: #7f8c8d; }
        
        .dark-mode .weather-section { background-color: #2c3e50; border-color: #4a6572; }
        .dark-mode .weather-section h2 { color: #ecf0f1; border-bottom-color: #4a6572; }
        .dark-mode .current-weather .temp { color: #ecf0f1; }
        .dark-mode .current-weather .desc { color: #bdc3c7; }
        .dark-mode .forecast-item { background-color: #34495e; box-shadow: 0 2px 5px rgba(0,0,0,0.15); color: #ecf0f1; }
        .dark-mode .forecast-item .temp { color: #f39c12; }
        .dark-mode .forecast-item .precip { color: #5dade2; }
        .dark-mode .chart-container { background-color: #2c3e50; border-color: #4a6572;}
        .dark-mode .svg-chart text { fill: #bdc3c7; }
        .dark-mode .status-bar.success { background-color: #1e4620; color: #a5d6a7; }
        .dark-mode .status-bar.error { background-color: #5e0000; color: #ef9a9a; }
        .dark-mode .status-bar.info { background-color: #0d47a1; color: #90caf9; }

        .icon-small { width: 24px; height: 24px; vertical-align: middle; margin-right: 5px; }
        .warning {
            background-color: #fff3cd;
            color: #856404;
            padding: 15px;
            border: 1px solid #ffeeba;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .footer-note {
            text-align: center; font-size: 0.8em; color: #7f8c8d; margin-top: 20px;
        }
        .dark-mode .footer-note { color: #bdc3c7; }

    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>HavaDurumuX - Ã‡evrimdÄ±ÅŸÄ± SÃ¼rÃ¼m</h1>
            <p>Bu sÃ¼rÃ¼m, temel hava durumu bilgilerini internet baÄŸlantÄ±sÄ± olmadan sunmayÄ± hedefler. Veriler periyodik olarak gÃ¼ncellenir.</p>
            <button id="toggleDarkMode">Koyu Modu AÃ§/Kapat</button>
        </header>

        <div class="warning">
            <strong>Ã–NEMLÄ° NOT:</strong> Bu Ã§evrimdÄ±ÅŸÄ± sÃ¼rÃ¼m bir konsept kanÄ±tÄ±dÄ±r.
            DoÄŸru hava durumu verileri iÃ§in illerin/ilÃ§elerin coÄŸrafi koordinatlarÄ±nÄ±n (`lat`, `lon`) aÅŸaÄŸÄ±daki JavaScript kodunda yer alan `provinceLocationData` dizisi iÃ§inde **doÄŸru ve eksiksiz** olarak tanÄ±mlanmasÄ± **kritik Ã¶nem taÅŸÄ±maktadÄ±r**. BirÃ§ok ilÃ§e iÃ§in varsayÄ±lan olarak 0.0, 0.0 atanmÄ±ÅŸtÄ±r, bu da API'nin doÄŸru veri dÃ¶ndÃ¼rmesini engelleyecektir. LÃ¼tfen bu koordinatlarÄ± gÃ¼ncelleyiniz.
        </div>

        <select id="provinceSelect"></select>
        <button id="updateAllDataButton">TÃ¼m Ä°llerin Verilerini Yenile (YaklaÅŸÄ±k 2-3 dk sÃ¼rebilir)</button>
        <button id="clearLocalDataButton" style="background-color: #e74c3c;">Yerel Verileri Temizle</button>
        
        <div id="statusBar" class="status-bar">Durum mesajlarÄ± burada gÃ¶sterilecek.</div>
        <div id="lastUpdateTime" style="font-size: 0.8em; text-align: center; margin-bottom: 15px;"></div>

        <div id="weatherDisplay" style="display: none;">
            <div class="weather-section current-weather">
                <h2 id="currentLocationName"></h2>
                <p id="currentWeatherTime" style="font-size:0.9em;"></p>
                <div id="currentWeatherIcon" style="margin: 10px 0;"></div>
                <div id="currentTemperature" class="temp">--Â°C</div>
                <p id="currentWeatherDescription" class="desc">--</p>
                <div class="current-weather-details">
                    <p>Hissedilen: <span id="currentApparentTemperature">--</span>Â°C</p>
                    <p>Nem: <span id="currentHumidity">--</span>%</p>
                    <p>RÃ¼zgar: <span id="currentWindSpeed">--</span> km/s (<span id="currentWindDirection">--</span>)</p>
                    <p>RÃ¼zgar Hamlesi: <span id="currentWindGusts">--</span> km/s</p>
                    <p>BasÄ±nÃ§: <span id="currentPressure">--</span> hPa</p>
                    <p>GÃ¶rÃ¼ÅŸ Mesafesi: <span id="currentVisibility">--</span> km</p>
                    <p>UV Ä°ndeksi: <span id="currentUvIndex">--</span></p>
                    <p>YaÄŸÄ±ÅŸ (1sa): <span id="currentPrecipitation">--</span> mm</p>
                </div>
            </div>

            <div class="weather-section">
                <h2>Saatlik Tahmin (Ä°lk 24 Saat)</h2>
                <div id="hourlyForecast" class="forecast-grid"></div>
                <div class="chart-container">
                    <p class="chart-title">Saatlik SÄ±caklÄ±k DeÄŸiÅŸimi (Â°C)</p>
                    <svg id="hourlyTempChart" class="svg-chart" width="100%" height="150"></svg>
                </div>
                <div class="chart-container">
                    <p class="chart-title">Saatlik YaÄŸÄ±ÅŸ Ä°htimali (%)</p>
                    <svg id="hourlyPrecipChart" class="svg-chart" width="100%" height="150"></svg>
                </div>
            </div>

            <div class="weather-section">
                <h2>GÃ¼nlÃ¼k Tahmin (7 GÃ¼n)</h2>
                <div id="dailyForecast" class="forecast-grid" style="grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));"></div>
            </div>
        </div>
         <div class="footer-note">
            Hava durumu verileri MET Norway (yr.no) ve Open-Meteo API'lerinden saÄŸlanmaktadÄ±r.
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const MET_API_BASE_URL = 'https://api.met.no/weatherapi/locationforecast/2.0/compact';
        const OPEN_METEO_API_BASE_URL = 'https://api.open-meteo.com/v1/forecast';
        const USER_AGENT = 'HavaDurumuXOffline/1.0 (havadurumuxsite@gmail.com)';
        const BULK_UPDATE_INTERVAL_MS = 6 * 60 * 60 * 1000; // 6 hours
        const REQUEST_DELAY_MS = 2000; // 2 seconds between requests during bulk update
        const M_S_TO_KM_H = 3.6; // Conversion factor for m/s to km/h

        // --- LOCATION DATA (Merkez Ä°lÃ§eler) ---
        // !!! Ã–NEMLÄ°: AÅŸaÄŸÄ±daki lat ve lon deÄŸerleri Ã§oÄŸunlukla 0.0, 0.0'dÄ±r.
        // !!! DoÄŸru hava durumu iÃ§in bu koordinatlarÄ±n GÃœNCELLENMESÄ° GEREKÄ°R!
        const turkeyLocationsRaw = {
          "Adana": [{ "name": "Merkez", "lat": 37.00, "lon": 35.32 }], // Ã–rnek: Adana Merkez koordinatlarÄ±
          "AdÄ±yaman": [{ "name": "Merkez", "lat": 37.76, "lon": 38.27 }],
          "Afyonkarahisar": [{ "name": "Merkez", "lat": 38.75, "lon": 30.53 }],
          "AÄŸrÄ±": [{ "name": "Merkez", "lat": 39.72, "lon": 43.05 }],
          "Aksaray": [{ "name": "Merkez", "lat": 38.37, "lon": 34.03 }],
          "Amasya": [{ "name": "Merkez", "lat": 40.65, "lon": 35.83 }],
          "Ankara": [{ "name": "Ã‡ankaya", "lat": 39.92, "lon": 32.85 }], // JSON'dan
          "Antalya": [{ "name": "MuratpaÅŸa", "lat": 36.89, "lon": 30.70 }], // JSON'dan
          "Ardahan": [{ "name": "Merkez", "lat": 41.11, "lon": 42.70 }],
          "Artvin": [{ "name": "Merkez", "lat": 41.18, "lon": 41.82 }],
          "AydÄ±n": [{ "name": "Efeler", "lat": 37.84, "lon": 27.84 }], // Efeler, AydÄ±n merkez
          "BalÄ±kesir": [{ "name": "Karesi", "lat": 39.65, "lon": 27.88 }], // Karesi, BalÄ±kesir merkez
          "BartÄ±n": [{ "name": "Merkez", "lat": 41.63, "lon": 32.33 }],
          "Batman": [{ "name": "Merkez", "lat": 37.88, "lon": 41.13 }],
          "Bayburt": [{ "name": "Merkez", "lat": 40.25, "lon": 40.22 }],
          "Bilecik": [{ "name": "Merkez", "lat": 40.14, "lon": 29.98 }],
          "BingÃ¶l": [{ "name": "Merkez", "lat": 38.88, "lon": 40.49 }],
          "Bitlis": [{ "name": "Merkez", "lat": 38.40, "lon": 42.11 }],
          "Bolu": [{ "name": "Merkez", "lat": 40.73, "lon": 31.60 }],
          "Burdur": [{ "name": "Merkez", "lat": 37.72, "lon": 30.28 }],
          "Bursa": [{ "name": "Osmangazi", "lat": 40.19, "lon": 29.06 }], // Osmangazi, Bursa merkez
          "Ã‡anakkale": [{ "name": "Merkez", "lat": 40.15, "lon": 26.41 }],
          "Ã‡ankÄ±rÄ±": [{ "name": "Merkez", "lat": 40.60, "lon": 33.61 }],
          "Ã‡orum": [{ "name": "Merkez", "lat": 40.55, "lon": 34.95 }],
          "Denizli": [{ "name": "Merkezefendi", "lat": 37.78, "lon": 29.09 }], // Merkezefendi, Denizli merkez
          "DiyarbakÄ±r": [{ "name": "Sur", "lat": 37.91, "lon": 40.23 }], // Sur, DiyarbakÄ±r merkez
          "DÃ¼zce": [{ "name": "Merkez", "lat": 40.84, "lon": 31.15 }],
          "Edirne": [{ "name": "Merkez", "lat": 41.67, "lon": 26.57 }],
          "ElazÄ±ÄŸ": [{ "name": "Merkez", "lat": 38.67, "lon": 39.22 }],
          "Erzincan": [{ "name": "Merkez", "lat": 39.74, "lon": 39.49 }],
          "Erzurum": [{ "name": "Yakutiye", "lat": 39.90, "lon": 41.27 }], // Yakutiye, Erzurum merkez
          "EskiÅŸehir": [{ "name": "OdunpazarÄ±", "lat": 39.77, "lon": 30.52 }], // OdunpazarÄ±, EskiÅŸehir merkez
          "Gaziantep": [{ "name": "Åžahinbey", "lat": 37.06, "lon": 37.37 }], // Åžahinbey, Gaziantep merkez
          "Giresun": [{ "name": "Merkez", "lat": 40.91, "lon": 38.39 }],
          "GÃ¼mÃ¼ÅŸhane": [{ "name": "Merkez", "lat": 40.46, "lon": 39.48 }],
          "Hakkari": [{ "name": "Merkez", "lat": 37.57, "lon": 43.74 }],
          "Hatay": [{ "name": "Antakya", "lat": 36.20, "lon": 36.16 }], // Antakya, Hatay merkez
          "IÄŸdÄ±r": [{ "name": "Merkez", "lat": 39.92, "lon": 44.04 }],
          "Isparta": [{ "name": "Merkez", "lat": 37.76, "lon": 30.55 }],
          "Ä°stanbul": [{ "name": "KadÄ±kÃ¶y", "lat": 40.99, "lon": 29.02 }], // JSON'dan
          "Ä°zmir": [{ "name": "Konak", "lat": 38.42, "lon": 27.14 }], // JSON'dan
          "KahramanmaraÅŸ": [{ "name": "OnikiÅŸubat", "lat": 37.57, "lon": 36.92 }], // OnikiÅŸubat, K.MaraÅŸ merkez
          "KarabÃ¼k": [{ "name": "Merkez", "lat": 41.20, "lon": 32.62 }],
          "Karaman": [{ "name": "Merkez", "lat": 37.18, "lon": 33.21 }],
          "Kars": [{ "name": "Merkez", "lat": 40.60, "lon": 43.09 }],
          "Kastamonu": [{ "name": "Merkez", "lat": 41.37, "lon": 33.77 }],
          "Kayseri": [{ "name": "Melikgazi", "lat": 38.72, "lon": 35.48 }], // Melikgazi, Kayseri merkez
          "Kilis": [{ "name": "Merkez", "lat": 36.71, "lon": 37.11 }],
          "KÄ±rÄ±kkale": [{ "name": "Merkez", "lat": 39.84, "lon": 33.51 }],
          "KÄ±rklareli": [{ "name": "Merkez", "lat": 41.73, "lon": 27.22 }],
          "KÄ±rÅŸehir": [{ "name": "Merkez", "lat": 39.14, "lon": 34.16 }],
          "Kocaeli": [{ "name": "Ä°zmit", "lat": 40.76, "lon": 29.91 }], // Ä°zmit, Kocaeli merkez
          "Konya": [{ "name": "SelÃ§uklu", "lat": 37.87, "lon": 32.49 }], // SelÃ§uklu, Konya merkez
          "KÃ¼tahya": [{ "name": "Merkez", "lat": 39.42, "lon": 29.98 }],
          "Malatya": [{ "name": "YeÅŸilyurt", "lat": 38.35, "lon": 38.30 }], // YeÅŸilyurt, Malatya merkez
          "Manisa": [{ "name": "Åžehzadeler", "lat": 38.61, "lon": 27.42 }], // Åžehzadeler, Manisa merkez
          "Mardin": [{ "name": "Artuklu", "lat": 37.31, "lon": 40.73 }], // Artuklu, Mardin merkez
          "Mersin": [{ "name": "Akdeniz", "lat": 36.80, "lon": 34.63 }], // Akdeniz, Mersin merkez
          "MuÄŸla": [{ "name": "MenteÅŸe", "lat": 37.21, "lon": 28.36 }], // MenteÅŸe, MuÄŸla merkez
          "MuÅŸ": [{ "name": "Merkez", "lat": 38.73, "lon": 41.49 }],
          "NevÅŸehir": [{ "name": "Merkez", "lat": 38.62, "lon": 34.71 }],
          "NiÄŸde": [{ "name": "Merkez", "lat": 37.96, "lon": 34.67 }],
          "Ordu": [{ "name": "AltÄ±nordu", "lat": 40.98, "lon": 37.87 }], // AltÄ±nordu, Ordu merkez
          "Osmaniye": [{ "name": "Merkez", "lat": 37.07, "lon": 36.24 }],
          "Rize": [{ "name": "Merkez", "lat": 41.02, "lon": 40.52 }],
          "Sakarya": [{ "name": "AdapazarÄ±", "lat": 40.78, "lon": 30.40 }], // AdapazarÄ±, Sakarya merkez
          "Samsun": [{ "name": "Ä°lkadÄ±m", "lat": 41.28, "lon": 36.33 }], // Ä°lkadÄ±m, Samsun merkez
          "ÅžanlÄ±urfa": [{ "name": "EyyÃ¼biye", "lat": 37.15, "lon": 38.79 }], // EyyÃ¼biye, ÅžanlÄ±urfa merkez
          "Siirt": [{ "name": "Merkez", "lat": 37.93, "lon": 41.94 }],
          "Sinop": [{ "name": "Merkez", "lat": 42.02, "lon": 35.15 }],
          "ÅžÄ±rnak": [{ "name": "Merkez", "lat": 37.51, "lon": 42.45 }],
          "Sivas": [{ "name": "Merkez", "lat": 39.75, "lon": 37.01 }],
          "TekirdaÄŸ": [{ "name": "SÃ¼leymanpaÅŸa", "lat": 40.97, "lon": 27.51 }], // SÃ¼leymanpaÅŸa, TekirdaÄŸ merkez
          "Tokat": [{ "name": "Merkez", "lat": 40.32, "lon": 36.55 }],
          "Trabzon": [{ "name": "Ortahisar", "lat": 41.00, "lon": 39.72 }], // Ortahisar, Trabzon merkez
          "Tunceli": [{ "name": "Merkez", "lat": 39.10, "lon": 39.54 }],
          "UÅŸak": [{ "name": "Merkez", "lat": 38.68, "lon": 29.40 }],
          "Van": [{ "name": "Ä°pekyolu", "lat": 38.50, "lon": 43.37 }], // Ä°pekyolu, Van merkez
          "Yalova": [{ "name": "Merkez", "lat": 40.65, "lon": 29.27 }],
          "Yozgat": [{ "name": "Merkez", "lat": 39.82, "lon": 34.81 }],
          "Zonguldak": [{ "name": "Merkez", "lat": 41.45, "lon": 31.79 }]
        };

        const provinceLocationData = Object.entries(turkeyLocationsRaw).map(([province, districts]) => {
            const merkezDistrict = districts.find(d => d.name.toLowerCase().includes("merkez") || d.name.toLowerCase().includes(province.toLowerCase()) || districts.length === 1);
            // Ã–zel durumlar (JSON'dan gelen temsili merkezler)
            if (province === "Ankara") return { name: `${province} / Ã‡ankaya`, province: province, district: "Ã‡ankaya", lat: 39.92, lon: 32.85 };
            if (province === "Ä°stanbul") return { name: `${province} / KadÄ±kÃ¶y`, province: province, district: "KadÄ±kÃ¶y", lat: 40.99, lon: 29.02 };
            if (province === "Ä°zmir") return { name: `${province} / Konak`, province: province, district: "Konak", lat: 38.42, lon: 27.14 };
            if (province === "Antalya") return { name: `${province} / MuratpaÅŸa`, province: province, district: "MuratpaÅŸa", lat: 36.89, lon: 30.70 };

            if (merkezDistrict) {
                return { name: `${province} / ${merkezDistrict.name}`, province: province, district: merkezDistrict.name, lat: merkezDistrict.lat, lon: merkezDistrict.lon };
            }
            // EÄŸer "Merkez" yoksa ve Ã¶zel durum deÄŸilse, ilk ilÃ§eyi al (veya o ili atla)
            // Bu Ã¶rnekte, eÄŸer "Merkez" yoksa ve Ã¶zel bir durum deÄŸilse, o ili atlayacaÄŸÄ±z.
            // Veya JSON dosyanÄ±zda her il iÃ§in temsili bir "merkez ilÃ§e" olduÄŸundan emin olmalÄ±sÄ±nÄ±z.
            // Bu prototip iÃ§in, koordinatlarÄ± 0 olanlar da listeye eklenecek ama uyarÄ± gÃ¶sterilecek.
            const firstDistrict = districts[0];
            if(firstDistrict) {
                 return { name: `${province} / ${firstDistrict.name} (Merkez DeÄŸil/Belirsiz)`, province: province, district: firstDistrict.name, lat: firstDistrict.lat, lon: firstDistrict.lon };
            }
            return null;

        }).filter(p => p !== null).sort((a, b) => a.province.localeCompare(b.province, 'tr'));


        // --- DOM ELEMENTS ---
        const provinceSelect = document.getElementById('provinceSelect');
        const updateAllDataButton = document.getElementById('updateAllDataButton');
        const clearLocalDataButton = document.getElementById('clearLocalDataButton');
        const statusBar = document.getElementById('statusBar');
        const lastUpdateTimeEl = document.getElementById('lastUpdateTime');
        const weatherDisplay = document.getElementById('weatherDisplay');
        const currentLocationNameEl = document.getElementById('currentLocationName');
        const currentWeatherTimeEl = document.getElementById('currentWeatherTime');
        const currentWeatherIconEl = document.getElementById('currentWeatherIcon');
        const currentTemperatureEl = document.getElementById('currentTemperature');
        const currentWeatherDescriptionEl = document.getElementById('currentWeatherDescription');
        const currentApparentTemperatureEl = document.getElementById('currentApparentTemperature');
        const currentHumidityEl = document.getElementById('currentHumidity');
        const currentWindSpeedEl = document.getElementById('currentWindSpeed');
        const currentWindDirectionEl = document.getElementById('currentWindDirection');
        const currentWindGustsEl = document.getElementById('currentWindGusts');
        const currentPressureEl = document.getElementById('currentPressure');
        const currentVisibilityEl = document.getElementById('currentVisibility');
        const currentUvIndexEl = document.getElementById('currentUvIndex');
        const currentPrecipitationEl = document.getElementById('currentPrecipitation');
        const hourlyForecastEl = document.getElementById('hourlyForecast');
        const dailyForecastEl = document.getElementById('dailyForecast');
        const hourlyTempChartEl = document.getElementById('hourlyTempChart');
        const hourlyPrecipChartEl = document.getElementById('hourlyPrecipChart');
        const toggleDarkModeButton = document.getElementById('toggleDarkMode');

        // --- STATE ---
        let currentSelectedProvinceKey = null;
        let temperatureAnimationInterval = null;

        // --- WEATHER ICON MAPPING (Simplified) ---
        const weatherCodeMap = {
            0: { description: 'AÃ§Ä±k', icon: 'â˜€ï¸' }, 1: { description: 'ParÃ§alÄ± Bulutlu', icon: 'ðŸŒ¤ï¸' },
            2: { description: 'Bulutlu', icon: 'â˜ï¸' }, 3: { description: 'Ã‡ok Bulutlu', icon: 'ðŸŒ¥ï¸' },
            45: { description: 'Sisli', icon: 'ðŸŒ«ï¸' }, 48: { description: 'KÄ±raÄŸÄ± Sisi', icon: 'ðŸŒ«ï¸' },
            51: { description: 'Hafif Ã‡isenti', icon: 'ðŸŒ¦ï¸' }, 53: { description: 'Orta Ã‡isenti', icon: 'ðŸŒ¦ï¸' },
            55: { description: 'YoÄŸun Ã‡isenti', icon: 'ðŸŒ§ï¸' }, 56: { description: 'Hafif Donan Ã‡isenti', icon: 'ðŸŒ¨ï¸' },
            57: { description: 'YoÄŸun Donan Ã‡isenti', icon: 'ðŸŒ¨ï¸' }, 61: { description: 'Hafif YaÄŸmurlu', icon: 'ðŸŒ§ï¸' },
            63: { description: 'Orta YaÄŸmurlu', icon: 'ðŸŒ§ï¸' }, 65: { description: 'Åžiddetli YaÄŸmurlu', icon: 'ðŸŒ§ï¸' },
            66: { description: 'Hafif Donan YaÄŸmur', icon: 'ðŸŒ¨ï¸' }, 67: { description: 'YoÄŸun Donan YaÄŸmur', icon: 'ðŸŒ¨ï¸' },
            71: { description: 'Hafif Kar', icon: 'ðŸŒ¨ï¸' }, 73: { description: 'Orta Kar', icon: 'â„ï¸' },
            75: { description: 'YoÄŸun Kar', icon: 'â„ï¸' }, 77: { description: 'Kar Taneleri', icon: 'â„ï¸' },
            80: { description: 'Hafif SaÄŸanak', icon: 'ðŸŒ¦ï¸' }, 81: { description: 'Orta SaÄŸanak', icon: 'ðŸŒ§ï¸' },
            82: { description: 'Åžiddetli SaÄŸanak', icon: 'â›ˆï¸' }, 85: { description: 'Hafif Kar SaÄŸanaÄŸÄ±', icon: 'ðŸŒ¨ï¸' },
            86: { description: 'YoÄŸun Kar SaÄŸanaÄŸÄ±', icon: 'â„ï¸' }, 95: { description: 'GÃ¶k GÃ¼rÃ¼ltÃ¼lÃ¼ FÄ±rtÄ±na', icon: 'â›ˆï¸' },
            96: { description: 'Hafif Dolu ile FÄ±rtÄ±na', icon: 'â›ˆï¸ðŸ§Š' }, 99: { description: 'YoÄŸun Dolu ile FÄ±rtÄ±na', icon: 'â›ˆï¸ðŸ§Š' }
        };

        function getWeatherInfo(code, isDay = true) {
            const info = weatherCodeMap[code];
            if (info) {
                if (code === 0 && !isDay) return { description: 'AÃ§Ä±k (Gece)', icon: 'ðŸŒ™' };
                return info;
            }
            return { description: 'Bilinmiyor', icon: 'â“' };
        }
        
        function getWindDirectionSymbol(degrees) {
            if (degrees === null || degrees === undefined) return 'N/A';
            const directions = ['K', 'KKD', 'KD', 'DKD', 'D', 'DGD', 'GD', 'GGD', 'G', 'GGB', 'GB', 'BGB', 'B', 'BKB', 'KB', 'KKB'];
            return directions[Math.round(degrees / 22.5) % 16];
        }

        // --- DARK MODE ---
        function applyDarkModePreference() {
            if (localStorage.getItem('havadurumux-offline-dark-mode') === 'true') {
                document.body.classList.add('dark-mode');
            } else {
                document.body.classList.remove('dark-mode');
            }
        }
        toggleDarkModeButton.addEventListener('click', () => {
            document.body.classList.toggle('dark-mode');
            localStorage.setItem('havadurumux-offline-dark-mode', document.body.classList.contains('dark-mode'));
        });

        // --- API SERVICE ---
        async function fetchWeatherDataFromMET(lat, lon) {
            const url = `${MET_API_BASE_URL}?lat=${lat}&lon=${lon}`;
            try {
                const response = await fetch(url, { headers: { 'User-Agent': USER_AGENT } });
                if (!response.ok) {
                    throw new Error(`MET API Error: ${response.status} ${response.statusText}`);
                }
                return await response.json();
            } catch (error) {
                console.error("Error fetching from MET API:", error);
                throw error;
            }
        }
        
        async function fetchWeatherDataFromOpenMeteo(lat, lon) {
            const params = new URLSearchParams({
                latitude: lat,
                longitude: lon,
                current: 'apparent_temperature,visibility,uv_index,wind_gusts_10m,precipitation,relative_humidity_2m,surface_pressure,cloud_cover',
                hourly: 'apparent_temperature,precipitation_probability,visibility,uv_index,wind_gusts_10m,soil_temperature_0cm,soil_moisture_0_1cm,pressure_msl,rain,showers,snowfall,cloud_cover',
                daily: 'sunrise,sunset,uv_index_max,precipitation_probability_max,wind_gusts_10m_max,apparent_temperature_max,apparent_temperature_min,rain_sum,showers_sum,snowfall_sum,precipitation_hours',
                forecast_days: 7, // Max forecast days matching MET, adjust if needed
                timezone: 'auto'
            });
            const url = `${OPEN_METEO_API_BASE_URL}?${params.toString()}`;
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`OpenMeteo API Error: ${response.status}`);
                }
                return await response.json();
            } catch (error) {
                console.error("Error fetching from OpenMeteo API:", error);
                return null; // Return null if OpenMeteo fails, MET data will still be used
            }
        }


        function processWeatherData(metData, openMeteoData, provinceKey) {
            if (!metData || !metData.properties || !metData.properties.timeseries) {
                console.error("Invalid MET data structure for", provinceKey, metData);
                return null;
            }
            const timeseries = metData.properties.timeseries;
            const forecastUntil = new Date();
            forecastUntil.setHours(forecastUntil.getHours() + 66);

            const relevantTimeseries = timeseries.filter(ts => new Date(ts.time) <= forecastUntil);

            const now = new Date();
            let currentDataPoint = relevantTimeseries.find(ts => new Date(ts.time) >= now) || relevantTimeseries[relevantTimeseries.length - 1];
             if (!currentDataPoint && relevantTimeseries.length > 0) { // Fallback to latest if no future point
                currentDataPoint = relevantTimeseries[relevantTimeseries.length -1];
             }


            const omCurrent = openMeteoData?.current || {};
            const omHourly = openMeteoData?.hourly || {};
            const omDaily = openMeteoData?.daily || {};

            const current = {
                time: currentDataPoint.time,
                temperature_2m: currentDataPoint.data.instant.details.air_temperature,
                apparent_temperature: omCurrent.apparent_temperature ?? currentDataPoint.data.instant.details.air_temperature, // Fallback
                relative_humidity_2m: currentDataPoint.data.instant.details.relative_humidity,
                is_day: new Date(currentDataPoint.time).getHours() > 6 && new Date(currentDataPoint.time).getHours() < 20 ? 1:0, // Simple day check
                precipitation: omCurrent.precipitation ?? currentDataPoint.data.next_1_hours?.details?.precipitation_amount ?? 0,
                weather_code: getWeatherInfo(currentDataPoint.data.next_1_hours?.summary?.symbol_code || currentDataPoint.data.next_6_hours?.summary?.symbol_code).wmoCode || 0, // Simplified
                cloud_cover: omCurrent.cloud_cover ?? currentDataPoint.data.instant.details.cloud_area_fraction,
                surface_pressure: omCurrent.surface_pressure ?? currentDataPoint.data.instant.details.air_pressure_at_sea_level,
                wind_speed_10m: (currentDataPoint.data.instant.details.wind_speed * M_S_TO_KM_H).toFixed(1),
                wind_direction_10m: currentDataPoint.data.instant.details.wind_from_direction,
                wind_gusts_10m: omCurrent.wind_gusts_10m ? omCurrent.wind_gusts_10m.toFixed(1) : 'N/A',
                visibility: omCurrent.visibility ? (omCurrent.visibility / 1000).toFixed(1) : 'N/A',
                uv_index: omCurrent.uv_index ?? 'N/A',
            };

            const hourly = relevantTimeseries.map((ts, index) => {
                const omHourIndex = omHourly.time?.findIndex(omt => new Date(omt).getTime() === new Date(ts.time).getTime());
                const omHourData = omHourIndex !== -1 && omHourly.temperature_2m ? {
                    apparent_temperature: omHourly.apparent_temperature[omHourIndex],
                    precipitation_probability: omHourly.precipitation_probability[omHourIndex],
                    visibility: omHourly.visibility[omHourIndex],
                    uv_index: omHourly.uv_index[omHourIndex],
                    wind_gusts_10m: omHourly.wind_gusts_10m[omHourIndex],
                    cloud_cover: omHourly.cloud_cover[omHourIndex],
                    pressure_msl: omHourly.pressure_msl[omHourIndex],
                } : {};

                return {
                    time: ts.time,
                    temperature_2m: ts.data.instant.details.air_temperature,
                    apparent_temperature: omHourData.apparent_temperature ?? ts.data.instant.details.air_temperature,
                    relative_humidity_2m: ts.data.instant.details.relative_humidity,
                    precipitation_probability: omHourData.precipitation_probability ?? 0, // default 0 if not from OM
                    precipitation: ts.data.next_1_hours?.details?.precipitation_amount ?? 0,
                    weather_code: getWeatherInfo(ts.data.next_1_hours?.summary?.symbol_code || ts.data.next_6_hours?.summary?.symbol_code).wmoCode || 0,
                    wind_speed_10m: (ts.data.instant.details.wind_speed * M_S_TO_KM_H),
                    wind_direction_10m: ts.data.instant.details.wind_from_direction,
                    wind_gusts_10m: omHourData.wind_gusts_10m,
                    cloud_cover: omHourData.cloud_cover ?? ts.data.instant.details.cloud_area_fraction,
                    pressure_msl: omHourData.pressure_msl ?? ts.data.instant.details.air_pressure_at_sea_level,
                };
            });

            const daily = [];
            if(omDaily.time && omDaily.time.length > 0) {
                for (let i = 0; i < Math.min(omDaily.time.length, 7); i++) {
                    daily.push({
                        time: omDaily.time[i],
                        weather_code: omDaily.weather_code ? omDaily.weather_code[i] : getWeatherInfo(hourly.find(h => h.time.startsWith(omDaily.time[i]))?.weather_code).wmoCode || 0, // Fallback
                        temperature_2m_max: omDaily.temperature_2m_max ? omDaily.temperature_2m_max[i] : null,
                        temperature_2m_min: omDaily.temperature_2m_min ? omDaily.temperature_2m_min[i] : null,
                        apparent_temperature_max: omDaily.apparent_temperature_max ? omDaily.apparent_temperature_max[i] : null,
                        apparent_temperature_min: omDaily.apparent_temperature_min ? omDaily.apparent_temperature_min[i] : null,
                        sunrise: omDaily.sunrise ? omDaily.sunrise[i] : null,
                        sunset: omDaily.sunset ? omDaily.sunset[i] : null,
                        uv_index_max: omDaily.uv_index_max ? omDaily.uv_index_max[i] : null,
                        precipitation_sum: omDaily.precipitation_sum ? omDaily.precipitation_sum[i] : null,
                        precipitation_probability_max: omDaily.precipitation_probability_max ? omDaily.precipitation_probability_max[i] : null,
                        wind_gusts_10m_max: omDaily.wind_gusts_10m_max ? omDaily.wind_gusts_10m_max[i] : null,
                        rain_sum: omDaily.rain_sum ? omDaily.rain_sum[i] : null,
                        showers_sum: omDaily.showers_sum ? omDaily.showers_sum[i] : null,
                        snowfall_sum: omDaily.snowfall_sum ? omDaily.snowfall_sum[i] : null,
                        precipitation_hours: omDaily.precipitation_hours ? omDaily.precipitation_hours[i] : null,
                    });
                }
            } else { // Fallback if OpenMeteo daily fails, derive from MET hourly
                const dailyAggregated = {};
                hourly.forEach(h => {
                    const day = h.time.split('T')[0];
                    if (!dailyAggregated[day]) {
                        dailyAggregated[day] = {
                            temps: [], precips: [], codes: [], windSpeeds: [], gusts: []
                        };
                    }
                    dailyAggregated[day].temps.push(h.temperature_2m);
                    dailyAggregated[day].precips.push(h.precipitation);
                    dailyAggregated[day].codes.push(h.weather_code);
                    dailyAggregated[day].windSpeeds.push(h.wind_speed_10m);
                    if(h.wind_gusts_10m) dailyAggregated[day].gusts.push(h.wind_gusts_10m);

                });

                Object.keys(dailyAggregated).slice(0, 7).forEach(dayKey => {
                    const dayData = dailyAggregated[dayKey];
                    const dominantCode = dayData.codes.sort((a,b) => dayData.codes.filter(v => v===a).length - dayData.codes.filter(v => v===b).length).pop();
                    daily.push({
                        time: dayKey,
                        weather_code: dominantCode,
                        temperature_2m_max: Math.max(...dayData.temps),
                        temperature_2m_min: Math.min(...dayData.temps),
                        precipitation_sum: dayData.precips.reduce((a,b) => a+b, 0),
                        // ... (sunrise/sunset etc. would still be missing here)
                    });
                });
            }


            return {
                latitude: metData.geometry.coordinates[1],
                longitude: metData.geometry.coordinates[0],
                current,
                hourly,
                daily,
                fetchedAt: new Date().toISOString()
            };
        }


        // --- LOCALSTORAGE SERVICE ---
        function saveDataToLocalStorage(provinceKey, data) {
            try {
                localStorage.setItem(`offline_weather_${provinceKey}`, JSON.stringify(data));
            } catch (e) {
                console.error("Error saving to localStorage (quota likely exceeded):", e);
                updateStatus("Yerel depolama dolu, eski veriler gÃ¶steriliyor olabilir.", true);
            }
        }

        function loadDataFromLocalStorage(provinceKey) {
            const data = localStorage.getItem(`offline_weather_${provinceKey}`);
            return data ? JSON.parse(data) : null;
        }

        function getLastBulkUpdateTime() {
            return localStorage.getItem('offline_lastBulkUpdateTime');
        }

        function setLastBulkUpdateTime() {
            localStorage.setItem('offline_lastBulkUpdateTime', new Date().toISOString());
        }
        
        clearLocalDataButton.addEventListener('click', () => {
            if (confirm("TÃ¼m kaydedilmiÅŸ hava durumu verilerini silmek istediÄŸinizden emin misiniz?")) {
                provinceLocationData.forEach(pData => {
                    localStorage.removeItem(`offline_weather_${pData.province}_${pData.district}`);
                });
                localStorage.removeItem('offline_lastBulkUpdateTime');
                localStorage.removeItem('offline_selectedProvinceKey');
                updateStatus("TÃ¼m yerel veriler silindi.", false);
                weatherDisplay.style.display = 'none';
                lastUpdateTimeEl.textContent = 'Son GÃ¼ncelleme: HenÃ¼z yok';
                currentSelectedProvinceKey = provinceLocationData[0]?.name; // Reset to first province
                if (provinceSelect.options.length > 0) provinceSelect.value = currentSelectedProvinceKey;
                checkAndLoadDataForProvince(currentSelectedProvinceKey);
            }
        });

        // --- UI SERVICE ---
        function updateStatus(message, isError = false) {
            statusBar.textContent = message;
            statusBar.className = 'status-bar'; // Reset
            if (isError) statusBar.classList.add('error');
            else statusBar.classList.add('info');
        }

        function displayWeatherData(data, locationDisplayName) {
            if (!data) {
                updateStatus(`${locationDisplayName} iÃ§in hava durumu verisi bulunamadÄ±.`, true);
                weatherDisplay.style.display = 'none';
                return;
            }
            weatherDisplay.style.display = 'block';
            updateStatus(`${locationDisplayName} iÃ§in hava durumu gÃ¶steriliyor. Son API Ã‡ekme: ${new Date(data.fetchedAt).toLocaleString('tr-TR')}`, false);

            // Current Weather
            const { current, hourly, daily } = data;
            currentLocationNameEl.textContent = locationDisplayName;
            currentWeatherTimeEl.textContent = `Tahmin ZamanÄ±: ${new Date(current.time).toLocaleString('tr-TR', { weekday: 'long', hour: '2-digit', minute: '2-digit' })}`;
            
            const currentWInfo = getWeatherInfo(current.weather_code, current.is_day);
            currentWeatherIconEl.innerHTML = `<span style="font-size: 3em;" title="${currentWInfo.description}">${currentWInfo.icon}</span>`;
            currentWeatherDescriptionEl.textContent = currentWInfo.description;

            // Kademeli sÄ±caklÄ±k
            if (temperatureAnimationInterval) clearInterval(temperatureAnimationInterval);
            let displayTemp = parseFloat(current.temperature_2m);
            currentTemperatureEl.textContent = `${displayTemp.toFixed(1)}Â°C`;

            const currentHourIndex = hourly.findIndex(h => new Date(h.time) >= new Date(current.time));
            const nextHourData = hourly[currentHourIndex + 1];

            if (nextHourData) {
                const tempDiff = parseFloat(nextHourData.temperature_2m) - displayTemp;
                const steps = 60 * 2; // 2 steps per minute for an hour transition (adjust for smoother/faster)
                const increment = tempDiff / steps;
                let currentStep = 0;
                temperatureAnimationInterval = setInterval(() => {
                    if (currentStep < steps) {
                        displayTemp += increment;
                        currentTemperatureEl.textContent = `${displayTemp.toFixed(1)}Â°C`;
                        currentStep++;
                    } else {
                        clearInterval(temperatureAnimationInterval);
                        currentTemperatureEl.textContent = `${parseFloat(nextHourData.temperature_2m).toFixed(1)}Â°C`; // Ensure final value
                    }
                }, 30000 / steps); // Total 30 seconds for transition (adjust as needed)
            }


            currentApparentTemperatureEl.textContent = current.apparent_temperature?.toFixed(1) ?? 'N/A';
            currentHumidityEl.textContent = current.relative_humidity_2m?.toFixed(0) ?? 'N/A';
            currentWindSpeedEl.textContent = current.wind_speed_10m ?? 'N/A';
            currentWindDirectionEl.textContent = getWindDirectionSymbol(current.wind_direction_10m);
            currentWindGustsEl.textContent = current.wind_gusts_10m ?? 'N/A';
            currentPressureEl.textContent = current.surface_pressure?.toFixed(0) ?? 'N/A';
            currentVisibilityEl.textContent = current.visibility ?? 'N/A';
            currentUvIndexEl.textContent = current.uv_index ?? 'N/A';
            currentPrecipitationEl.textContent = current.precipitation?.toFixed(1) ?? 'N/A';


            // Hourly Forecast
            hourlyForecastEl.innerHTML = ''; // Clear previous
            hourly.slice(0, 24).forEach(hour => {
                const hourEl = document.createElement('div');
                hourEl.classList.add('forecast-item');
                const hourTime = new Date(hour.time);
                const wInfo = getWeatherInfo(hour.weather_code, hourTime.getHours() > 6 && hourTime.getHours() < 20);
                hourEl.innerHTML = `
                    <div class="time">${hourTime.toLocaleTimeString('tr-TR', { hour: '2-digit', minute: '2-digit' })}</div>
                    <div style="font-size: 1.5em;" title="${wInfo.description}">${wInfo.icon}</div>
                    <div class="temp">${hour.temperature_2m?.toFixed(1) ?? 'N/A'}Â°C</div>
                    <div class="desc" style="font-size:0.8em;">${wInfo.description}</div>
                    <div class="precip" title="YaÄŸÄ±ÅŸ Ä°htimali">ðŸ’§ ${hour.precipitation_probability?.toFixed(0) ?? 'N/A'}%</div>
                    <div class="precip" title="YaÄŸÄ±ÅŸ MiktarÄ±">â˜” ${hour.precipitation?.toFixed(1) ?? 'N/A'}mm</div>
                `;
                hourlyForecastEl.appendChild(hourEl);
            });
            
            // Daily Forecast
            dailyForecastEl.innerHTML = '';
            daily.forEach(day => {
                const dayEl = document.createElement('div');
                dayEl.classList.add('forecast-item');
                const date = new Date(day.time);
                const wInfo = getWeatherInfo(day.weather_code, true); // Assume day for daily icon
                dayEl.innerHTML = `
                    <div class="time">${date.toLocaleDateString('tr-TR', { weekday: 'short', day: 'numeric', month: 'short' })}</div>
                    <div style="font-size: 1.8em;" title="${wInfo.description}">${wInfo.icon}</div>
                    <div>${wInfo.description}</div>
                    <div class="temp">Max: ${day.temperature_2m_max?.toFixed(1) ?? 'N/A'}Â°C</div>
                    <div class="temp">Min: ${day.temperature_2m_min?.toFixed(1) ?? 'N/A'}Â°C</div>
                    <div class="precip" title="YaÄŸÄ±ÅŸ Ä°htimali">ðŸ’§ ${day.precipitation_probability_max?.toFixed(0) ?? 'N/A'}%</div>
                    <div class="precip" title="Toplam YaÄŸÄ±ÅŸ">â˜” ${day.precipitation_sum?.toFixed(1) ?? 'N/A'}mm</div>
                `;
                dailyForecastEl.appendChild(dayEl);
            });

            // Charts
            createBarChart(hourlyTempChartEl, hourly.slice(0, 24).map(h => ({ label: new Date(h.time).getHours() + ':00', value: h.temperature_2m })), 'SÄ±caklÄ±k (Â°C)', '#e67e22');
            createBarChart(hourlyPrecipChartEl, hourly.slice(0, 24).map(h => ({ label: new Date(h.time).getHours() + ':00', value: h.precipitation_probability })), 'YaÄŸÄ±ÅŸ Ä°htimali (%)', '#3498db', 100);
        }

        function createBarChart(svgElement, data, unit, color, maxValue = null) {
            svgElement.innerHTML = ''; // Clear previous chart
            const chartWidth = svgElement.clientWidth || 300;
            const chartHeight = svgElement.clientHeight || 150;
            const barPadding = 5;
            const barWidth = (chartWidth - (data.length + 1) * barPadding) / data.length;
            
            const values = data.map(d => d.value === null || d.value === undefined ? 0 : d.value);
            const yMax = maxValue !== null ? maxValue : (Math.max(...values) > 0 ? Math.max(...values) : 10); // Ensure yMax is not 0
            const yMin = Math.min(...values) < 0 ? Math.min(...values) : 0; // Handle negative temps
            const yRange = yMax - yMin;

            data.forEach((d, i) => {
                const barHeight = yRange === 0 ? 0 : ((d.value - yMin) / yRange) * (chartHeight - 20); // -20 for labels
                const x = barPadding + i * (barWidth + barPadding);
                const y = chartHeight - 15 - barHeight; // -15 for x-axis labels

                const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                rect.setAttribute('x', x);
                rect.setAttribute('y', y);
                rect.setAttribute('width', barWidth);
                rect.setAttribute('height', Math.max(0, barHeight)); // Ensure non-negative height
                rect.setAttribute('fill', color);
                rect.setAttribute('rx', '3');
                rect.setAttribute('ry', '3');
                svgElement.appendChild(rect);

                const textLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
                textLabel.setAttribute('x', x + barWidth / 2);
                textLabel.setAttribute('y', chartHeight - 5);
                textLabel.setAttribute('text-anchor', 'middle');
                textLabel.textContent = d.label;
                svgElement.appendChild(textLabel);
                
                const textValue = document.createElementNS("http://www.w3.org/2000/svg", "text");
                textValue.setAttribute('x', x + barWidth / 2);
                textValue.setAttribute('y', y - 3);
                textValue.setAttribute('text-anchor', 'middle');
                textValue.setAttribute('font-size', '9px');
                textValue.textContent = d.value?.toFixed(0) + (unit.includes('%') ? '%' : 'Â°');
                svgElement.appendChild(textValue);
            });
        }

        // --- APP LOGIC ---
        async function checkAndLoadDataForProvince(provinceKeyToLoad) {
            const location = provinceLocationData.find(p => p.name === provinceKeyToLoad);
            if (!location) {
                updateStatus(`SeÃ§ilen konum (${provinceKeyToLoad}) bulunamadÄ±.`, true);
                return;
            }
            
            if (location.lat === 0.0 && location.lon === 0.0) {
                updateStatus(`${location.name} iÃ§in geÃ§erli koordinat bulunamadÄ±. LÃ¼tfen HTML dosyasÄ±ndaki koordinatlarÄ± gÃ¼ncelleyin.`, true);
                 weatherDisplay.style.display = 'none';
                return;
            }

            let data = loadDataFromLocalStorage(`${location.province}_${location.district}`);
            const now = new Date().getTime();

            if (data && (now - new Date(data.fetchedAt).getTime()) < BULK_UPDATE_INTERVAL_MS) {
                updateStatus(`${location.name} iÃ§in yerel veriler kullanÄ±lÄ±yor.`, false);
                displayWeatherData(data, location.name);
            } else {
                updateStatus(`${location.name} iÃ§in MET Norway ve OpenMeteo API'lerinden veri Ã§ekiliyor...`, false);
                try {
                    const metData = await fetchWeatherDataFromMET(location.lat, location.lon);
                    const openMeteoData = await fetchWeatherDataFromOpenMeteo(location.lat, location.lon);
                    
                    const processedData = processWeatherData(metData, openMeteoData, `${location.province}_${location.district}`);
                    if (processedData) {
                        saveDataToLocalStorage(`${location.province}_${location.district}`, processedData);
                        displayWeatherData(processedData, location.name);
                    } else {
                         updateStatus(`${location.name} iÃ§in veri iÅŸlenemedi.`, true);
                    }
                } catch (error) {
                    updateStatus(`${location.name} iÃ§in veri Ã§ekilemedi: ${error.message}. Yerel veri varsa o gÃ¶steriliyor.`, true);
                    if(data) displayWeatherData(data, location.name); // Show stale data if fetch fails
                    else weatherDisplay.style.display = 'none';
                }
            }
        }
        
        let isBulkUpdating = false;
        async function initiateBulkUpdate() {
            if (isBulkUpdating) {
                updateStatus("Toplu gÃ¼ncelleme zaten devam ediyor.", true);
                return;
            }
            isBulkUpdating = true;
            updateAllDataButton.disabled = true;
            updateStatus("TÃ¼m iller iÃ§in toplu veri gÃ¼ncelleme baÅŸlatÄ±ldÄ±...", false);
            let successCount = 0;
            let errorCount = 0;

            for (let i = 0; i < provinceLocationData.length; i++) {
                const loc = provinceLocationData[i];
                if (loc.lat === 0.0 && loc.lon === 0.0) {
                    console.warn(`Skipping ${loc.name} due to 0.0 coordinates.`);
                    errorCount++;
                    updateStatus(`(${i+1}/${provinceLocationData.length}) ${loc.name} iÃ§in koordinat yok, atlanÄ±yor...`, true);
                    await new Promise(resolve => setTimeout(resolve, 50)); // Short delay for UI
                    continue;
                }

                updateStatus(`(${i+1}/${provinceLocationData.length}) ${loc.name} iÃ§in veri Ã§ekiliyor...`, false);
                try {
                    const metData = await fetchWeatherDataFromMET(loc.lat, loc.lon);
                    const openMeteoData = await fetchWeatherDataFromOpenMeteo(loc.lat, loc.lon);
                    const processedData = processWeatherData(metData, openMeteoData, `${loc.province}_${loc.district}`);
                    
                    if (processedData) {
                        saveDataToLocalStorage(`${loc.province}_${loc.district}`, processedData);
                        successCount++;
                    } else {
                        errorCount++;
                    }
                } catch (error) {
                    console.error(`Error fetching for ${loc.name}:`, error);
                    errorCount++;
                }
                if (i < provinceLocationData.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, REQUEST_DELAY_MS));
                }
            }
            setLastBulkUpdateTime();
            updateStatus(`Toplu gÃ¼ncelleme tamamlandÄ±. BaÅŸarÄ±lÄ±: ${successCount}, HatalÄ±: ${errorCount}.`, false);
            lastUpdateTimeEl.textContent = `TÃ¼m Veriler Son GÃ¼ncelleme: ${new Date().toLocaleString('tr-TR')}`;
            // Reload data for current selection if it was part of the bulk update
            if (currentSelectedProvinceKey) {
                checkAndLoadDataForProvince(currentSelectedProvinceKey);
            }
            isBulkUpdating = false;
            updateAllDataButton.disabled = false;
        }

        function populateProvinces() {
            provinceLocationData.forEach(pData => {
                if(pData){ // Ensure pData is not null
                    const option = document.createElement('option');
                    option.value = pData.name; // Use combined name as value for simplicity
                    option.textContent = pData.name;
                    provinceSelect.appendChild(option);
                }
            });
        }

        provinceSelect.addEventListener('change', (event) => {
            currentSelectedProvinceKey = event.target.value;
            localStorage.setItem('offline_selectedProvinceKey', currentSelectedProvinceKey);
            if (temperatureAnimationInterval) clearInterval(temperatureAnimationInterval); // Clear animation on province change
            checkAndLoadDataForProvince(currentSelectedProvinceKey);
        });

        updateAllDataButton.addEventListener('click', initiateBulkUpdate);

        function initApp() {
            applyDarkModePreference();
            populateProvinces();
            
            const lastSelected = localStorage.getItem('offline_selectedProvinceKey');
            currentSelectedProvinceKey = lastSelected || (provinceLocationData[0] ? provinceLocationData[0].name : null);

            if (currentSelectedProvinceKey && provinceSelect.options.length > 0) {
                 // Check if the value exists in options
                let valueExists = false;
                for(let i=0; i < provinceSelect.options.length; i++){
                    if(provinceSelect.options[i].value === currentSelectedProvinceKey){
                        valueExists = true;
                        break;
                    }
                }
                if(valueExists) {
                    provinceSelect.value = currentSelectedProvinceKey;
                } else {
                     currentSelectedProvinceKey = provinceLocationData[0] ? provinceLocationData[0].name : null; // fallback to first
                     if(currentSelectedProvinceKey) provinceSelect.value = currentSelectedProvinceKey;
                }
            }


            const lastUpdateTimestamp = getLastBulkUpdateTime();
            if (lastUpdateTimestamp) {
                lastUpdateTimeEl.textContent = `TÃ¼m Veriler Son GÃ¼ncelleme: ${new Date(lastUpdateTimestamp).toLocaleString('tr-TR')}`;
                if (new Date().getTime() - new Date(lastUpdateTimestamp).getTime() > BULK_UPDATE_INTERVAL_MS) {
                    updateStatus("Veriler 6 saatten eski, toplu gÃ¼ncelleme Ã¶nerilir.", false);
                    // Optionally, auto-trigger update if user preference allows (not implemented here)
                    // initiateBulkUpdate(); 
                } else {
                     if(currentSelectedProvinceKey) checkAndLoadDataForProvince(currentSelectedProvinceKey);
                }
            } else {
                lastUpdateTimeEl.textContent = 'TÃ¼m Veriler Son GÃ¼ncelleme: HenÃ¼z yok. LÃ¼tfen gÃ¼ncelleyin.';
                // First time load, prompt for update or auto-start
                updateStatus("Ä°lk kullanÄ±m. TÃ¼m il verilerini Ã§ekmek iÃ§in 'TÃ¼m Ä°llerin Verilerini Yenile' butonuna tÄ±klayÄ±n.", false);
                // initiateBulkUpdate(); // Optionally auto-start on first load
            }
            
            if(!lastUpdateTimestamp && provinceLocationData.length > 0 && currentSelectedProvinceKey) {
                 // If no bulk update ever, and there's a selected province, try to load its data.
                 // This handles the case where the user has never done a bulk update but selected a province.
                 checkAndLoadDataForProvince(currentSelectedProvinceKey);
            }


        }

        // --- INITIALIZATION ---
        document.addEventListener('DOMContentLoaded', initApp);

    </script>
</body>
</html>

    