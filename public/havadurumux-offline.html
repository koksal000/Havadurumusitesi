<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HavaDurumuX - Çevrimdışı Sürüm</title>
    <link rel="manifest" href="/manifest-offline.json">
    <meta name="theme-color" content="#007bff">
    <style>
        /* General Styles */
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; line-height: 1.6; margin: 0; padding: 0; background-color: #f4f7f9; color: #333; display: flex; flex-direction: column; min-height: 100vh; }
        .container { max-width: 1000px; margin: 0 auto; padding: 15px; flex-grow: 1; }
        
        /* Header */
        header { background-color: #007bff; color: white; padding: 15px 0; text-align: center; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        header h1 { margin: 0; font-size: 1.8em; }
        .header-content { display: flex; justify-content: space-between; align-items: center; padding: 0 20px; max-width: 1000px; margin: 0 auto; flex-wrap: wrap; }
        .header-logo { font-weight: bold; font-size: 1.5em; }
        .header-controls { display: flex; gap: 10px; align-items: center; margin-top: 10px; sm:margin-top: 0;}
        .header-controls button, .header-controls select {
            padding: 8px 12px; border-radius: 5px; border: 1px solid #ddd; background-color: #fff; color: #007bff; cursor: pointer; font-size: 0.9em;
            transition: background-color 0.2s ease, box-shadow 0.2s ease; box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        .header-controls button:hover, .header-controls select:hover { background-color: #f0f0f0; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        #dataProgressIndicator { font-size: 0.9em; color: white; background-color: rgba(255,255,255,0.2); padding: 5px 10px; border-radius: 5px; }

        /* Tabs */
        .tabs { display: flex; margin-bottom: 15px; background-color: #e9ecef; border-radius: 8px; box-shadow: inset 0 1px 3px rgba(0,0,0,0.1); }
        .tab-button { flex-grow: 1; padding: 12px 10px; background-color: transparent; border: none; cursor: pointer; font-size: 0.95em; color: #495057; border-radius: 7px; transition: background-color 0.3s ease, color 0.3s ease; }
        .tab-button.active { background-color: #007bff; color: white; font-weight: bold; box-shadow: 0 2px 5px rgba(0,123,255,0.3); }
        .tab-content { display: none; animation: fadeIn 0.5s; }
        .tab-content.active { display: block; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        /* Weather Display Card */
        .weather-card { background-color: white; padding: 20px; border-radius: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); margin-bottom: 20px; }
        .location-title { font-size: 1.6em; font-weight: bold; color: #007bff; margin-bottom: 5px; }
        .current-time { font-size: 0.85em; color: #6c757d; margin-bottom: 15px; }
        .temperature-section { display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px; flex-wrap: wrap; }
        .weather-icon { width: 80px; height: 80px; margin-right: 20px; }
        .temperature { font-size: 3.5em; font-weight: bold; color: #212529; }
        .weather-description { font-size: 1.1em; color: #495057; text-align: right; flex-grow:1; }
        
        /* Details Section */
        .details-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; }
        .detail-item, .detail-card { background-color: #f8f9fa; padding: 12px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); }
        .detail-item h4, .detail-card h4 { margin-top: 0; margin-bottom: 8px; font-size: 0.9em; color: #007bff; font-weight: 600; }
        .detail-item p, .detail-card p { margin: 4px 0; font-size: 0.95em; color: #343a40; }

        /* Hourly Forecast */
        .hourly-forecast-container { display: flex; overflow-x: auto; padding-bottom: 15px; gap: 12px; }
        .hourly-item { background-color: #f8f9fa; min-width: 80px; padding: 10px; border-radius: 8px; text-align: center; box-shadow: 0 2px 5px rgba(0,0,0,0.05); }
        .hourly-item .time { font-size: 0.8em; font-weight: bold; margin-bottom: 5px; color: #495057; }
        .hourly-item .icon { width: 35px; height: 35px; margin: 5px auto; display: block; }
        .hourly-item .temp { font-size: 1em; font-weight: 500; color: #212529; }
        .hourly-item .precip { font-size: 0.75em; color: #007bff; margin-top:3px;}

        /* Daily Forecast */
        .daily-forecast-container .day-item { background-color: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); display: flex; justify-content: space-between; align-items: center; }
        .daily-forecast-container .day-item .date { font-weight: bold; font-size: 1em; color: #495057; }
        .daily-forecast-container .day-item .icon { width: 40px; height: 40px; }
        .daily-forecast-container .day-item .temps { font-size: 1em; font-weight: 500; color: #212529; }
        .daily-forecast-container .day-item .description { font-size: 0.85em; color: #6c757d; text-align: right;}

        /* Alerts Section */
        #alertsContainer .alert { padding: 12px; margin-bottom: 10px; border-radius: 5px; font-size: 0.9em; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        #alertsContainer .alert-warning { background-color: #fff3cd; color: #856404; border: 1px solid #ffeeba; }
        #alertsContainer .alert-info { background-color: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        #alertsContainer .alert-danger { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }

        /* Map Section */
        #mapContainer { width: 100%; height: 350px; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        #mapLocation { font-size: 0.9em; color: #6c757d; margin-top: 10px; display: block; text-align: center; }

        /* Loading Indicator */
        #loadingContainer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); color: white; display: flex; justify-content: center; align-items: center; z-index: 1000; text-align: center; flex-direction: column; display: none; }
        #loadingText { font-size: 1.2em; margin-bottom: 15px; }
        #progressBarContainer { width: 80%; max-width: 400px; background-color: #555; border-radius: 5px; overflow: hidden; height: 20px; }
        #progressBar { width: 0%; height: 100%; background-color: #007bff; transition: width 0.3s ease; text-align: center; line-height: 20px; font-size: 0.8em;}

        /* Footer */
        footer { text-align: center; padding: 15px; background-color: #343a40; color: white; font-size: 0.9em; margin-top: auto; }
        footer a { color: #00bcd4; text-decoration: none; }
        footer a:hover { text-decoration: underline; }

        /* Utility */
        .hidden { display: none !important; }
        .pt-2 { padding-top: 0.5rem; }
        .mb-2 { margin-bottom: 0.5rem; }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .header-content { flex-direction: column; }
            .header-controls { width: 100%; justify-content: space-around; margin-top:10px; }
            .tabs { flex-wrap: wrap; }
            .tab-button { font-size: 0.85em; padding: 10px 8px; }
            .temperature-section { flex-direction: column; align-items: center; text-align:center; }
            .weather-icon { margin-right: 0; margin-bottom: 10px; }
            .temperature { font-size: 3em; }
            .weather-description { text-align: center; }
        }
        @media (max-width: 480px) {
            .header-controls button, .header-controls select { font-size: 0.8em; padding: 6px 10px; }
            .tab-button { font-size: 0.75em; }
            .details-grid { grid-template-columns: 1fr; } /* Single column for very small screens */
        }
    </style>
</head>
<body>
    <header>
        <div class="header-content">
            <div class="header-logo">HavaDurumuX Çevrimdışı</div>
            <div id="dataProgressIndicator">Veri Durumu: 0 / 0</div>
            <div class="header-controls">
                <select id="provinceSelect" title="İl Seçin">
                    <option value="">İl Seçin</option>
                </select>
                <button id="majorCitiesButton">Büyük Şehirler</button>
                <button id="getLocationButton">Konumumu Bul</button>
                <button id="forceRefreshButton">Verileri Yenile</button>
            </div>
        </div>
    </header>

    <div class="container">
        <div class="tabs">
            <button class="tab-button active" data-tab="current">Anlık Durum</button>
            <button class="tab-button" data-tab="details">Ayrıntılar</button>
            <button class="tab-button" data-tab="hourly">Saatlik</button>
            <button class="tab-button" data-tab="daily">Günlük</button>
            <button class="tab-button" data-tab="alerts">Uyarılar</button>
            <button class="tab-button" data-tab="map">Harita</button>
        </div>

        <div id="currentWeatherTab" class="tab-content active">
            <div class="weather-card">
                <h2 id="locationName" class="location-title">Konum Yükleniyor...</h2>
                <p id="currentTime" class="current-time">--:--</p>
                <div class="temperature-section">
                    <img id="weatherIcon" src="https://www.placehold.co/100x100.png" alt="Hava Durumu İkonu" class="weather-icon" data-ai-hint="weather clear">
                    <div>
                        <span id="temperature" class="temperature">--°C</span>
                        <p id="weatherDescription" class="weather-description">Yükleniyor...</p>
                    </div>
                </div>
                <div class="details-grid">
                    <div class="detail-item"><h4>Hissedilen</h4><p id="feelsLike">--°C</p></div>
                    <div class="detail-item"><h4>Nem</h4><p id="humidity">--%</p></div>
                    <div class="detail-item"><h4>Rüzgar</h4><p id="wind">-- km/s</p></div>
                    <div class="detail-item"><h4>Basınç</h4><p id="pressure">-- hPa</p></div>
                    <div class="detail-item"><h4>Görüş Mesafesi</h4><p id="visibility">-- km</p></div>
                    <div class="detail-item"><h4>UV İndeksi</h4><p id="uvIndex">--</p></div>
                    <div class="detail-item"><h4>Gün Doğumu</h4><p id="sunrise">--:--</p></div>
                    <div class="detail-item"><h4>Gün Batımı</h4><p id="sunset">--:--</p></div>
                </div>
            </div>
        </div>

        <div id="detailsTab" class="tab-content">
            <h3>Ayrıntılı Bilgiler (<span id="detailsLocationName"></span>)</h3>
            <div id="detailsContainer" class="details-grid pt-2">
                <p>Ayrıntılar yükleniyor veya bu konum için mevcut değil...</p>
            </div>
        </div>
        
        <div id="hourlyTab" class="tab-content">
            <h3>Saatlik Tahmin (<span id="hourlyLocationName"></span>)</h3>
            <div id="hourlyForecastContainer" class="hourly-forecast-container pt-2">
                <p>Saatlik tahminler yükleniyor...</p>
            </div>
        </div>

        <div id="dailyTab" class="tab-content">
            <h3>Günlük Tahmin (<span id="dailyLocationName"></span>)</h3>
            <div id="dailyForecastContainer" class="daily-forecast-container pt-2">
                <p>Günlük tahminler yükleniyor...</p>
            </div>
        </div>
        
        <div id="alertsTab" class="tab-content">
            <h3>Meteoroloji Uyarıları (<span id="alertsLocationName"></span>)</h3>
            <div id="alertsContainer" class="pt-2">
                <p>Uyarılar kontrol ediliyor...</p>
            </div>
        </div>

        <div id="mapTab" class="tab-content">
            <h3>Konum Haritası</h3>
            <div id="mapContainer" class="pt-2">
                <p>Harita yükleniyor...</p>
            </div>
            <p id="mapLocation">Harita için bir konum seçin.</p>
        </div>

        <div class="weather-card mt-4" id="quickActionsCard" style="display:none;">
            <h4>Hızlı Eylemler (Büyük Şehirler)</h4>
            <div id="majorCitiesContainer" class="details-grid">
                <button class="detail-item quick-action-btn" data-province="İstanbul" data-district="Kadıköy">İstanbul (Kadıköy)</button>
                <button class="detail-item quick-action-btn" data-province="Ankara" data-district="Çankaya">Ankara (Çankaya)</button>
                <button class="detail-item quick-action-btn" data-province="İzmir" data-district="Konak">İzmir (Konak)</button>
                <button class="detail-item quick-action-btn" data-province="Bursa" data-district="Osmangazi">Bursa (Osmangazi)</button>
                <button class="detail-item quick-action-btn" data-province="Antalya" data-district="Muratpaşa">Antalya (Muratpaşa)</button>
                <button class="detail-item quick-action-btn" data-province="Kütahya" data-district="Domaniç">Kütahya (Domaniç)</button>
                <button class="detail-item quick-action-btn" data-province="Bursa" data-district="İnegöl">Bursa (İnegöl)</button>
            </div>
        </div>
    </div>

    <div id="loadingContainer">
        <div id="loadingText">Veriler Yükleniyor...</div>
        <div id="progressBarContainer">
            <div id="progressBar">0%</div>
        </div>
    </div>

    <footer>
        <p>&copy; <span id="currentYear"></span> HavaDurumuX Çevrimdışı. <a href="https{:/}/studio.met.no/products/compa{:/}/ct_MET_Norway" target="_blank" rel="noopener">MET Norway</a> ve <a href="https://open-meteo.com/" target="_blank" rel="noopener">Open-Meteo</a> API'leri kullanılarak veri sağlanmaktadır.</p>
        <p>Bu sürüm temel çevrimdışı kullanım için tasarlanmıştır.</p>
    </footer>

    <script>
        const DB_NAME = 'WeatherDB_v3';
        const DB_VERSION = 2; // Increment if schema changes
        const STORE_NAME = 'weather_data_v3';
        const BULK_REQUEST_DELAY = 5000; // 5 seconds
        const SIX_HOURS_MS = 6 * 60 * 60 * 1000;

        const MET_API_BASE_URL = 'https://api.met.no/weatherapi/locationforecast/2.0/compact';
        const OPEN_METEO_API_BASE_URL = 'https://api.open-meteo.com/v1/forecast';
        const MET_USER_AGENT = 'havadurumuxsite.offline/1.0 mail@example.com'; // Replace with actual contact for MET

        let db;
        let currentSelectedLocation = { province: null, district: null, lat: null, lon: null };
        let provincesToFetchForBulkUpdate = []; // Populated by fetchProvincesForBulk
        let TOTAL_TARGET_LOCATIONS = 0;

        // DOM Elements
        const locationNameEl = document.getElementById('locationName');
        const currentTimeEl = document.getElementById('currentTime');
        const weatherIconEl = document.getElementById('weatherIcon');
        const temperatureEl = document.getElementById('temperature');
        const weatherDescriptionEl = document.getElementById('weatherDescription');
        const feelsLikeEl = document.getElementById('feelsLike');
        const humidityEl = document.getElementById('humidity');
        const windEl = document.getElementById('wind');
        const pressureEl = document.getElementById('pressure');
        const visibilityEl = document.getElementById('visibility');
        const uvIndexEl = document.getElementById('uvIndex');
        const sunriseEl = document.getElementById('sunrise');
        const sunsetEl = document.getElementById('sunset');

        const detailsContainer = document.getElementById('detailsContainer');
        const detailsLocationNameEl = document.getElementById('detailsLocationName');
        const hourlyForecastContainer = document.getElementById('hourlyForecastContainer');
        const hourlyLocationNameEl = document.getElementById('hourlyLocationName');
        const dailyForecastContainer = document.getElementById('dailyForecastContainer');
        const dailyLocationNameEl = document.getElementById('dailyLocationName');
        const alertsContainer = document.getElementById('alertsContainer');
        const alertsLocationNameEl = document.getElementById('alertsLocationName');
        const mapContainer = document.getElementById('mapContainer');
        const mapLocationEl = document.getElementById('mapLocation');
        
        const provinceSelect = document.getElementById('provinceSelect');
        const majorCitiesButton = document.getElementById('majorCitiesButton');
        const getLocationButton = document.getElementById('getLocationButton');
        const forceRefreshButton = document.getElementById('forceRefreshButton');
        const majorCitiesContainer = document.getElementById('majorCitiesContainer');
        const quickActionsCard = document.getElementById('quickActionsCard');

        const loadingContainer = document.getElementById('loadingContainer');
        const loadingText = document.getElementById('loadingText');
        const progressBar = document.getElementById('progressBar');
        const dataProgressIndicator = document.getElementById('dataProgressIndicator');


        document.getElementById('currentYear').textContent = new Date().getFullYear();

        // WMO Weather Code to Description and Icon Mapping
        const WMO_CODES = {
            0: { desc: "Açık", icon_day: "01d.png", icon_night: "01n.png" },
            1: { desc: "Az Bulutlu", icon_day: "02d.png", icon_night: "02n.png" },
            2: { desc: "Parçalı Bulutlu", icon_day: "03d.png", icon_night: "03n.png" },
            3: { desc: "Çok Bulutlu", icon_day: "04d.png", icon_night: "04n.png" },
            45: { desc: "Sisli", icon_day: "50d.png", icon_night: "50n.png" },
            48: { desc: "Kırağı Sisi", icon_day: "50d.png", icon_night: "50n.png" },
            51: { desc: "Hafif Çisenti", icon_day: "09d.png", icon_night: "09n.png" },
            53: { desc: "Orta Çisenti", icon_day: "09d.png", icon_night: "09n.png" },
            55: { desc: "Yoğun Çisenti", icon_day: "09d.png", icon_night: "09n.png" },
            56: { desc: "Hafif Donan Çisenti", icon_day: "13d.png", icon_night: "13n.png" }, // Mixed
            57: { desc: "Yoğun Donan Çisenti", icon_day: "13d.png", icon_night: "13n.png" }, // Mixed
            61: { desc: "Hafif Yağmurlu", icon_day: "10d.png", icon_night: "10n.png" },
            63: { desc: "Orta Yağmurlu", icon_day: "10d.png", icon_night: "10n.png" },
            65: { desc: "Şiddetli Yağmurlu", icon_day: "10d.png", icon_night: "10n.png" },
            66: { desc: "Hafif Donan Yağmur", icon_day: "13d.png", icon_night: "13n.png" }, // Mixed
            67: { desc: "Yoğun Donan Yağmur", icon_day: "13d.png", icon_night: "13n.png" }, // Mixed
            71: { desc: "Hafif Kar", icon_day: "13d.png", icon_night: "13n.png" },
            73: { desc: "Orta Kar", icon_day: "13d.png", icon_night: "13n.png" },
            75: { desc: "Yoğun Kar", icon_day: "13d.png", icon_night: "13n.png" },
            77: { desc: "Kar Taneleri", icon_day: "13d.png", icon_night: "13n.png" },
            80: { desc: "Hafif Sağanak Yağmur", icon_day: "09d.png", icon_night: "09n.png" },
            81: { desc: "Orta Sağanak Yağmur", icon_day: "09d.png", icon_night: "09n.png" },
            82: { desc: "Şiddetli Sağanak Yağmur", icon_day: "09d.png", icon_night: "09n.png" },
            85: { desc: "Hafif Kar Sağanağı", icon_day: "13d.png", icon_night: "13n.png" },
            86: { desc: "Yoğun Kar Sağanağı", icon_day: "13d.png", icon_night: "13n.png" },
            95: { desc: "Gök Gürültülü Fırtına", icon_day: "11d.png", icon_night: "11n.png" },
            96: { desc: "Hafif Dolu ile Fırtına", icon_day: "11d.png", icon_night: "11n.png" }, // Mixed
            99: { desc: "Yoğun Dolu ile Fırtına", icon_day: "11d.png", icon_night: "11n.png" }  // Mixed
        };
        const DEFAULT_WEATHER_ICON = "https://www.placehold.co/64x64.png?text=N/A"; // Fallback icon

        function getWeatherIconPath(wmoCode, isDay = true) {
            const codeInfo = WMO_CODES[wmoCode];
            if (codeInfo) {
                const iconName = isDay ? codeInfo.icon_day : codeInfo.icon_night;
                // Assuming icons are in an 'img/weather_icons/' subfolder relative to this HTML
                return `https://openweathermap.org/img/wn/${iconName.replace('.png', '@2x.png')}`;
            }
            return DEFAULT_WEATHER_ICON;
        }

        function getWeatherDescription(wmoCode) {
            return WMO_CODES[wmoCode] ? WMO_CODES[wmoCode].desc : "Bilinmiyor";
        }
        
        function getWeatherCodeAndIsDay(symbolCode) {
            if (!symbolCode) return { wmo: 0, is_day: 1 }; // Default to clear day
            const baseSymbol = symbolCode.split('_')[0];
            const isDay = !symbolCode.includes("_night");
            
            // Simplified mapping from MET symbol base to WMO (extend as needed)
            const metSymbolToWMOMap = {
                "clearsky": 0, "fair": 1, "partlycloudy": 2, "cloudy": 3,
                "lightrain": 61, "rain": 63, "heavyrain": 65,
                "lightsnow": 71, "snow": 73, "heavysnow": 75,
                "fog": 45,
                "sleet": 67, "lightsleet":67, "heavysleet":67, // Approximate
                "rainshowers": 81, "lightrainshowers": 80, "heavyrainshowers": 82,
                "snowshowers": 85, "lightsnowshowers": 85, "heavysnowshowers": 86,
                "sleetshowers": 83, "lightsleetshowers": 83, "heavysleetshowers": 84, // Approximate
                "rainandthunder": 95, "lightrainandthunder":95, "heavyrainandthunder":97,
                "sleetandthunder": 95, // Approximate
                "snowandthunder": 95, // Approximate
            };
            // Try to find a more specific match first
            let wmo = metSymbolToWMOMap[symbolCode] || metSymbolToWMOMap[baseSymbol] || 0;
            return { wmo: wmo, is_day: isDay ? 1 : 0 };
        }


        function initDb() {
            const request = indexedDB.open(DB_NAME, DB_VERSION);
            request.onerror = (event) => console.error("DB Error:", event.target.error);
            
            request.onupgradeneeded = (event) => {
                db = event.target.result;
                if (!db.objectStoreNames.contains(STORE_NAME)) {
                    const store = db.createObjectStore(STORE_NAME, { keyPath: 'id' });
                    store.createIndex('province_district', ['province', 'district'], { unique: true });
                    console.log("Offline HTML: Object store created.");
                }
            };

            request.onsuccess = (event) => {
                db = event.target.result;
                console.log("Offline HTML: DB initialized successfully.");
                fetchProvincesForBulkUpdate().then(() => { // Fetch and set up provinces first
                    TOTAL_TARGET_LOCATIONS = provincesToFetchForBulkUpdate.length;
                    updateDataProgressIndicator(); // Initial update of the top indicator

                    loadDefaultOrLastSelectedLocation().then(() => {
                        // This will be called after the default location weather is displayed (or attempted)
                        const lastBulkUpdate = localStorage.getItem('lastBulkUpdateTime_v3');
                        const sixHours = SIX_HOURS_MS;
                        let autoUpdateNeeded = false;

                        if (!lastBulkUpdate) {
                            console.log('Offline HTML: No lastBulkUpdateTime_v3 found. Automatic bulk update will be triggered.');
                            autoUpdateNeeded = true;
                        } else {
                            const timeSinceLastUpdate = Date.now() - (parseInt(lastBulkUpdate) || 0);
                            if (timeSinceLastUpdate > sixHours) {
                                console.log(`Offline HTML: Last bulk update was ${Math.floor(timeSinceLastUpdate / (60*60*1000))} hours ago. Automatic bulk update will be triggered.`);
                                autoUpdateNeeded = true;
                            } else {
                                console.log(`Offline HTML: Last bulk update was at ${new Date(parseInt(lastBulkUpdate)).toLocaleString()}. No automatic bulk update needed yet. ${Math.ceil((sixHours - timeSinceLastUpdate)/(60*1000))} mins remaining.`);
                            }
                        }
                        
                        if (autoUpdateNeeded) {
                            bulkUpdateAllProvincesData(false); // false means it's a regular, time-based check
                        } else {
                            hideLoading(); // Hide main loading if no bulk update is immediately needed
                            updateDataProgressIndicator(); // Re-check progress after default load and decision
                        }
                    });
                });
            };
        }
        
        async function fetchProvincesForBulkUpdate() {
            // This is a simplified version. In a real app, you'd fetch this from a config or API.
            // For this offline HTML, we'll hardcode them.
            const allProvinces = [
                // Add all 81 provinces with their main district and coordinates
                // Example format: { province: "Ankara", district: "Çankaya", lat: 39.92077, lon: 32.85411 },
                // For brevity, I'll list a few and then the special ones.
                // YOU MUST POPULATE THIS WITH ALL 81 PROVINCES + THE SPECIAL ONES
                { province: "Adana", district: "Seyhan", lat: 37.0000, lon: 35.3213 },
                { province: "Ankara", district: "Çankaya", lat: 39.9208, lon: 32.8541 },
                { province: "Antalya", district: "Muratpaşa", lat: 36.8969, lon: 30.7133 },
                { province: "Bursa", district: "Osmangazi", lat: 40.1826, lon: 29.0669 },
                { province: "Diyarbakır", district: "Yenişehir", lat: 37.9144, lon: 40.2306 },
                { province: "Erzurum", district: "Yakutiye", lat: 39.9097, lon: 41.2750 },
                { province: "Eskişehir", district: "Odunpazarı", lat: 39.7667, lon: 30.5256 },
                { province: "Gaziantep", district: "Şahinbey", lat: 37.0662, lon: 37.3833 },
                { province: "İstanbul", district: "Fatih", lat: 41.0082, lon: 28.9784 }, // Using Fatih as central
                { province: "İzmir", district: "Konak", lat: 38.4237, lon: 27.1428 },
                { province: "Kayseri", district: "Melikgazi", lat: 38.7333, lon: 35.4833 },
                { province: "Kocaeli", district: "İzmit", lat: 40.7655, lon: 29.9408 },
                { province: "Konya", district: "Selçuklu", lat: 37.8746, lon: 32.4942 },
                { province: "Malatya", district: "Battalgazi", lat: 38.3552, lon: 38.3095 },
                { province: "Mersin", district: "Akdeniz", lat: 36.8121, lon: 34.6415 },
                { province: "Sakarya", district: "Adapazarı", lat: 40.7730, lon: 30.3948 },
                { province: "Samsun", district: "İlkadım", lat: 41.2798, lon: 36.3361 },
                { province: "Şanlıurfa", district: "Haliliye", lat: 37.1674, lon: 38.7950 },
                { province: "Trabzon", district: "Ortahisar", lat: 41.0027, lon: 39.7168 },
                { province: "Van", district: "İpekyolu", lat: 38.4891, lon: 43.3806 },
                // ... add all other 61 provinces ...
                // For example, just a few more placeholders:
                { province: "Afyonkarahisar", district: "Merkez", lat: 38.7569, lon: 30.5387 },
                { province: "Ağrı", district: "Merkez", lat: 39.7191, lon: 43.0542 },
                { province: "Amasya", district: "Merkez", lat: 40.6565, lon: 35.8353 },
                { province: "Artvin", district: "Merkez", lat: 41.1811, lon: 41.8194 },
                { province: "Aydın", district: "Efeler", lat: 37.8461, lon: 27.8417 },
                { province: "Balıkesir", district: "Karesi", lat: 39.6484, lon: 27.8826 },
                { province: "Bilecik", district: "Merkez", lat: 40.1425, lon: 29.9810 },
                { province: "Bingöl", district: "Merkez", lat: 38.8850, lon: 40.4983 },
                { province: "Bitlis", district: "Merkez", lat: 38.4009, lon: 42.1096 },
                { province: "Bolu", district: "Merkez", lat: 40.7321, lon: 31.6029 },
                { province: "Burdur", district: "Merkez", lat: 37.7268, lon: 30.2906 },
                { province: "Çanakkale", district: "Merkez", lat: 40.1467, lon: 26.4086 },
                { province: "Çankırı", district: "Merkez", lat: 40.6011, lon: 33.6140 },
                { province: "Çorum", district: "Merkez", lat: 40.5499, lon: 34.9537 },
                { province: "Denizli", district: "Merkezefendi", lat: 37.7833, lon: 29.0944 },
                { province: "Düzce", district: "Merkez", lat: 40.8430, lon: 31.1587 },
                { province: "Edirne", district: "Merkez", lat: 41.6764, lon: 26.5559 },
                { province: "Elazığ", district: "Merkez", lat: 38.6768, lon: 39.2289 },
                { province: "Erzincan", district: "Merkez", lat: 39.7481, lon: 39.4929 },
                { province: "Giresun", district: "Merkez", lat: 40.9175, lon: 38.3927 },
                { province: "Gümüşhane", district: "Merkez", lat: 40.4608, lon: 39.4769 },
                { province: "Hakkari", district: "Merkez", lat: 37.5744, lon: 43.7408 },
                { province: "Hatay", district: "Antakya", lat: 36.2023, lon: 36.1601 },
                { province: "Isparta", district: "Merkez", lat: 37.7637, lon: 30.5515 },
                { province: "Iğdır", district: "Merkez", lat: 39.9222, lon: 44.0450 },
                { province: "Kahramanmaraş", district: "Onikişubat", lat: 37.5753, lon: 36.9228 },
                { province: "Karabük", district: "Merkez", lat: 41.1975, lon: 32.6283 },
                { province: "Karaman", district: "Merkez", lat: 37.1811, lon: 33.2156 },
                { province: "Kars", district: "Merkez", lat: 40.6020, lon: 43.0952 },
                { province: "Kastamonu", district: "Merkez", lat: 41.3769, lon: 33.7763 },
                { province: "Kırıkkale", district: "Merkez", lat: 39.8466, lon: 33.5153 },
                { province: "Kırklareli", district: "Merkez", lat: 41.7350, lon: 27.2253 },
                { province: "Kırşehir", district: "Merkez", lat: 39.1461, lon: 34.1595 },
                { province: "Kilis", district: "Merkez", lat: 36.7167, lon: 37.1167 },
                { province: "Kütahya", district: "Merkez", lat: 39.4206, lon: 29.9833 },
                { province: "Manisa", district: "Yunusemre", lat: 38.6191, lon: 27.4258 },
                { province: "Mardin", district: "Artuklu", lat: 37.3129, lon: 40.7351 },
                { province: "Muğla", district: "Menteşe", lat: 37.2153, lon: 28.3636 },
                { province: "Muş", district: "Merkez", lat: 38.7341, lon: 41.4916 },
                { province: "Nevşehir", district: "Merkez", lat: 38.6247, lon: 34.7146 },
                { province: "Niğde", district: "Merkez", lat: 37.9666, lon: 34.6763 },
                { province: "Ordu", district: "Altınordu", lat: 40.9862, lon: 37.8797 },
                { province: "Osmaniye", district: "Merkez", lat: 37.0740, lon: 36.2464 },
                { province: "Rize", district: "Merkez", lat: 41.0201, lon: 40.5235 },
                { province: "Siirt", district: "Merkez", lat: 37.9330, lon: 41.9437 },
                { province: "Sinop", district: "Merkez", lat: 42.0259, lon: 35.1515 },
                { province: "Sivas", district: "Merkez", lat: 39.7477, lon: 37.0179 },
                { province: "Şırnak", district: "Merkez", lat: 37.5175, lon: 42.4611 },
                { province: "Tekirdağ", district: "Süleymanpaşa", lat: 40.9781, lon: 27.5117 },
                { province: "Tokat", district: "Merkez", lat: 40.3235, lon: 36.5531 },
                { province: "Tunceli", district: "Merkez", lat: 39.1061, lon: 39.5484 },
                { province: "Uşak", district: "Merkez", lat: 38.6823, lon: 29.4019 },
                { province: "Yalova", district: "Merkez", lat: 40.6550, lon: 29.2769 },
                { province: "Yozgat", district: "Merkez", lat: 39.8204, lon: 34.8069 },
                { province: "Zonguldak", district: "Merkez", lat: 41.4564, lon: 31.7987 },
                 // Special additions
                { province: "Kütahya", district: "Domaniç", lat: 39.8119, lon: 29.6078 },
                { province: "Bursa", district: "İnegöl", lat: 40.0792, lon: 29.5094 }
            ];
            // Remove duplicates just in case, preferring earlier entries for coordinate source
            const uniqueLocationsMap = new Map();
            allProvinces.forEach(loc => {
                const key = `${loc.province}-${loc.district}`;
                if (!uniqueLocationsMap.has(key)) {
                    uniqueLocationsMap.set(key, loc);
                }
            });
            provincesToFetchForBulkUpdate = Array.from(uniqueLocationsMap.values());
            TOTAL_TARGET_LOCATIONS = provincesToFetchForBulkUpdate.length;

            // Populate select dropdown
            provincesToFetchForBulkUpdate.sort((a,b) => a.province.localeCompare(b.province, 'tr')).forEach(loc => {
                if (loc.district === "Merkez" || loc.district === "Çankaya" || loc.district === "Konak" || loc.district === "Osmangazi" || loc.district === "Muratpaşa" || loc.district === "Seyhan" || loc.district === "Yakutiye" || loc.district === "Odunpazarı" || loc.district === "Şahinbey" || loc.district === "Fatih" || loc.district === "Melikgazi" || loc.district === "İzmit" || loc.district === "Selçuklu" || loc.district === "Battalgazi" || loc.district === "Akdeniz" || loc.district === "Adapazarı" || loc.district === "İlkadım" || loc.district === "Haliliye" || loc.district === "Ortahisar" || loc.district === "İpekyolu" || loc.district === "Domaniç" || loc.district === "İnegöl" || loc.district === "Yenişehir" || loc.district === "Artuklu" || loc.district === "Menteşe" || loc.district === "Altınordu" || loc.district === "Süleymanpaşa" || loc.district === "Onikişubat" || loc.district === "Yunusemre" || loc.district === "Efeler" || loc.district === "Merkezefendi") { // Show only main districts or special ones
                    const option = document.createElement('option');
                    option.value = `${loc.province}|${loc.district}|${loc.lat}|${loc.lon}`;
                    option.textContent = `${loc.province} / ${loc.district}`;
                    provinceSelect.appendChild(option);
                }
            });
        }
        
        async function updateDataProgressIndicator() {
            if (!db || provincesToFetchForBulkUpdate.length === 0) {
                dataProgressIndicator.textContent = `Veri Durumu: 0 / ${TOTAL_TARGET_LOCATIONS || provincesToFetchForBulkUpdate.length}`;
                return;
            }
            
            const transaction = db.transaction(STORE_NAME, 'readonly');
            const store = transaction.objectStore(STORE_NAME);
            let storedCount = 0;

            return new Promise((resolve) => {
                const countPromises = provincesToFetchForBulkUpdate.map(loc => {
                    return new Promise(resolveLoc => {
                        const request = store.get(`${loc.province}_${loc.district}`);
                        request.onsuccess = (event) => {
                            if (event.target.result) {
                                storedCount++;
                            }
                            resolveLoc();
                        };
                        request.onerror = () => resolveLoc(); // count as not stored on error
                    });
                });

                Promise.all(countPromises).then(() => {
                    dataProgressIndicator.textContent = `Veri Durumu: ${storedCount} / ${TOTAL_TARGET_LOCATIONS}`;
                    resolve();
                });
            });
        }


        async function fetchWeatherDataAndStore(province, district, lat, lon) {
            const locationId = `${province}_${district}`;
            console.log(`Offline HTML: Fetching data for ${locationId} from MET Norway...`);

            const metUrl = `${MET_API_BASE_URL}?lat=${lat}&lon=${lon}`;
            let metData;
            try {
                const metResponse = await fetch(metUrl, { headers: { 'User-Agent': MET_USER_AGENT }});
                if (!metResponse.ok) throw new Error(`MET.no API error: ${metResponse.status}`);
                metData = await metResponse.json();
            } catch (error) {
                console.error(`Offline HTML: Error fetching MET.no data for ${locationId}:`, error);
                return null; // Stop if primary source fails
            }

            if (!metData || !metData.properties || !metData.properties.timeseries || metData.properties.timeseries.length === 0) {
                console.warn(`Offline HTML: No timeseries data from MET.no for ${locationId}`);
                return null;
            }
            
            // Prepare Open-Meteo supplementary data fetch
            // Note: visibility is in meters from Open-Meteo
            const current_params = "temperature_2m,relative_humidity_2m,apparent_temperature,is_day,precipitation,weather_code,cloud_cover,surface_pressure,wind_speed_10m,wind_direction_10m,wind_gusts_10m,uv_index,visibility,rain,showers,snowfall,pressure_msl";
            const hourly_params = "temperature_2m,relative_humidity_2m,apparent_temperature,precipitation_probability,precipitation,rain,showers,snowfall,weather_code,surface_pressure,cloud_cover,visibility,wind_speed_10m,wind_direction_10m,wind_gusts_10m,uv_index,is_day,pressure_msl,soil_temperature_0cm,soil_moisture_0_1cm";
            const daily_params = "weather_code,temperature_2m_max,temperature_2m_min,apparent_temperature_max,apparent_temperature_min,sunrise,sunset,uv_index_max,uv_index_clear_sky_max,precipitation_sum,rain_sum,showers_sum,snowfall_sum,precipitation_hours,precipitation_probability_max,wind_speed_10m_max,wind_gusts_10m_max,wind_direction_10m_dominant,shortwave_radiation_sum,et0_fao_evapotranspiration";
            
            const openMeteoUrl = `${OPEN_METEO_API_BASE_URL}?latitude=${lat}&longitude=${lon}&current=${current_params}&hourly=${hourly_params}&daily=${daily_params}&timezone=auto&forecast_days=7`; // Fetch 7 days for daily
            
            let openMeteoData = null;
            try {
                console.log(`Offline HTML: Fetching supplementary data for ${locationId} from Open-Meteo...`);
                const openMeteoResponse = await fetch(openMeteoUrl);
                if (openMeteoResponse.ok) {
                    openMeteoData = await openMeteoResponse.json();
                    console.log(`Offline HTML: Open-Meteo current data for ${locationId}:`, openMeteoData.current);
                } else {
                    console.warn(`Offline HTML: Open-Meteo API error for ${locationId}: ${openMeteoResponse.status}`);
                }
            } catch (error) {
                console.warn(`Offline HTML: Error fetching Open-Meteo data for ${locationId}:`, error);
            }

            // --- Process MET Norway Data (Primary) ---
            let metTimeseries = metData.properties.timeseries;
            
            // Current Weather from MET
            let metCurrentInstant = metTimeseries[0].data.instant.details;
            let metNext1HourSummary = metTimeseries[0].data.next_1_hours ? metTimeseries[0].data.next_1_hours.summary : null;
            let metNext1HourDetails = metTimeseries[0].data.next_1_hours ? metTimeseries[0].data.next_1_hours.details : null;
            let symbol_code_current = metNext1HourSummary ? metNext1HourSummary.symbol_code : (metTimeseries[0].data.next_6_hours ? metTimeseries[0].data.next_6_hours.summary.symbol_code : 'clearsky_day');
            const { wmo: currentWMO, is_day: currentIsDay } = getWeatherCodeAndIsDay(symbol_code_current);

            const currentWeatherObjectForStorage = {
                time: metTimeseries[0].time,
                temperature_2m: metCurrentInstant.air_temperature,
                relative_humidity_2m: metCurrentInstant.relative_humidity,
                apparent_temperature: null, // To be filled by Open-Meteo
                is_day: currentIsDay,
                precipitation: metNext1HourDetails ? metNext1HourDetails.precipitation_amount : 0,
                rain: null, showers: null, snowfall: null, // To be detailed by Open-Meteo or symbol
                weather_code: currentWMO,
                cloud_cover: metCurrentInstant.cloud_area_fraction,
                surface_pressure: metCurrentInstant.air_pressure_at_sea_level, // MET uses sea level pressure
                wind_speed_10m: metCurrentInstant.wind_speed * 3.6, // m/s to km/h
                wind_direction_10m: metCurrentInstant.wind_from_direction,
                wind_gusts_10m: null, // To be filled by Open-Meteo
                uv_index: null, // To be filled by Open-Meteo
                visibility: null, // To be filled by Open-Meteo
                pressure_msl: metCurrentInstant.air_pressure_at_sea_level, // Same as surface for MET
            };
             // Refine rain/showers/snowfall based on MET symbol if OpenMeteo fails for these
            if (symbol_code_current.includes('rain')) currentWeatherObjectForStorage.rain = currentWeatherObjectForStorage.precipitation;
            if (symbol_code_current.includes('snow')) currentWeatherObjectForStorage.snowfall = currentWeatherObjectForStorage.precipitation;
            if (symbol_code_current.includes('showers')) currentWeatherObjectForStorage.showers = currentWeatherObjectForStorage.precipitation;


            // Hourly Weather from MET (limited to 7 days)
            const hourlyDataForStorage = {
                time: [], temperature_2m: [], relative_humidity_2m: [], apparent_temperature: [],
                precipitation_probability: [], precipitation: [], rain: [], showers: [], snowfall: [],
                weather_code: [], surface_pressure: [], cloud_cover: [], visibility: [],
                wind_speed_10m: [], wind_direction_10m: [], wind_gusts_10m: [], uv_index: [], is_day: [],
                pressure_msl: [], soil_temperature_0cm: [], soil_moisture_0_1cm: []
            };

            const sevenDaysFromNow = new Date();
            sevenDaysFromNow.setDate(sevenDaysFromNow.getDate() + 7);

            metTimeseries.forEach(ts => {
                if (new Date(ts.time) > sevenDaysFromNow) return;

                let tsInstant = ts.data.instant.details;
                let tsNext1Summary = ts.data.next_1_hours ? ts.data.next_1_hours.summary : null;
                let tsNext1Details = ts.data.next_1_hours ? ts.data.next_1_hours.details : null;
                let symbol_code_hourly = tsNext1Summary ? tsNext1Summary.symbol_code : (ts.data.next_6_hours ? ts.data.next_6_hours.summary.symbol_code : 'clearsky_day');
                const { wmo: hourlyWMO, is_day: hourlyIsDay } = getWeatherCodeAndIsDay(symbol_code_hourly);

                hourlyDataForStorage.time.push(ts.time);
                hourlyDataForStorage.temperature_2m.push(tsInstant.air_temperature);
                hourlyDataForStorage.relative_humidity_2m.push(tsInstant.relative_humidity);
                hourlyDataForStorage.precipitation.push(tsNext1Details ? tsNext1Details.precipitation_amount : 0);
                hourlyDataForStorage.weather_code.push(hourlyWMO);
                hourlyDataForStorage.cloud_cover.push(tsInstant.cloud_area_fraction);
                hourlyDataForStorage.surface_pressure.push(tsInstant.air_pressure_at_sea_level);
                hourlyDataForStorage.pressure_msl.push(tsInstant.air_pressure_at_sea_level);
                hourlyDataForStorage.wind_speed_10m.push(tsInstant.wind_speed * 3.6);
                hourlyDataForStorage.wind_direction_10m.push(tsInstant.wind_from_direction);
                hourlyDataForStorage.is_day.push(hourlyIsDay);
                
                // Placeholders for Open-Meteo
                hourlyDataForStorage.apparent_temperature.push(null);
                hourlyDataForStorage.precipitation_probability.push(null);
                hourlyDataForStorage.rain.push(symbol_code_hourly.includes('rain') ? (tsNext1Details ? tsNext1Details.precipitation_amount : 0) : 0);
                hourlyDataForStorage.showers.push(symbol_code_hourly.includes('showers') ? (tsNext1Details ? tsNext1Details.precipitation_amount : 0) : 0);
                hourlyDataForStorage.snowfall.push(symbol_code_hourly.includes('snow') ? (tsNext1Details ? tsNext1Details.precipitation_amount : 0) : 0);
                hourlyDataForStorage.visibility.push(null);
                hourlyDataForStorage.wind_gusts_10m.push(null);
                hourlyDataForStorage.uv_index.push(null);
                hourlyDataForStorage.soil_temperature_0cm.push(null);
                hourlyDataForStorage.soil_moisture_0_1cm.push(null);
            });

            // --- Supplement with Open-Meteo Data ---
            if (openMeteoData) {
                // Supplement Current
                if (openMeteoData.current) {
                    const omCurrent = openMeteoData.current;
                    currentWeatherObjectForStorage.apparent_temperature = omCurrent.apparent_temperature ?? currentWeatherObjectForStorage.apparent_temperature;
                    currentWeatherObjectForStorage.uv_index = omCurrent.uv_index ?? currentWeatherObjectForStorage.uv_index;
                    currentWeatherObjectForStorage.visibility = omCurrent.visibility ?? currentWeatherObjectForStorage.visibility;
                    currentWeatherObjectForStorage.wind_gusts_10m = omCurrent.wind_gusts_10m ?? currentWeatherObjectForStorage.wind_gusts_10m;
                    currentWeatherObjectForStorage.rain = omCurrent.rain ?? currentWeatherObjectForStorage.rain;
                    currentWeatherObjectForStorage.showers = omCurrent.showers ?? currentWeatherObjectForStorage.showers;
                    currentWeatherObjectForStorage.snowfall = omCurrent.snowfall ?? currentWeatherObjectForStorage.snowfall;
                    if (omCurrent.pressure_msl !== undefined && omCurrent.pressure_msl !== null) { // Prefer OpenMeteo for overall pressure if available
                        currentWeatherObjectForStorage.surface_pressure = omCurrent.pressure_msl;
                        currentWeatherObjectForStorage.pressure_msl = omCurrent.pressure_msl;
                    }
                     if (omCurrent.cloud_cover !== undefined && omCurrent.cloud_cover !== null) {
                        currentWeatherObjectForStorage.cloud_cover = omCurrent.cloud_cover;
                    }
                }

                // Supplement Hourly
                if (openMeteoData.hourly && openMeteoData.hourly.time) {
                    const omHourly = openMeteoData.hourly;
                    omHourly.time.forEach((omTimeISO, omIdx) => {
                        const metIdx = hourlyDataForStorage.time.findIndex(metTimeISO => new Date(metTimeISO).getTime() === new Date(omTimeISO).getTime());
                        if (metIdx !== -1) {
                            hourlyDataForStorage.apparent_temperature[metIdx] = omHourly.apparent_temperature?.[omIdx] ?? hourlyDataForStorage.apparent_temperature[metIdx];
                            hourlyDataForStorage.precipitation_probability[metIdx] = omHourly.precipitation_probability?.[omIdx] ?? hourlyDataForStorage.precipitation_probability[metIdx];
                            hourlyDataForStorage.rain[metIdx] = omHourly.rain?.[omIdx] ?? hourlyDataForStorage.rain[metIdx];
                            hourlyDataForStorage.showers[metIdx] = omHourly.showers?.[omIdx] ?? hourlyDataForStorage.showers[metIdx];
                            hourlyDataForStorage.snowfall[metIdx] = omHourly.snowfall?.[omIdx] ?? hourlyDataForStorage.snowfall[metIdx];
                            hourlyDataForStorage.visibility[metIdx] = omHourly.visibility?.[omIdx] ?? hourlyDataForStorage.visibility[metIdx];
                            hourlyDataForStorage.wind_gusts_10m[metIdx] = omHourly.wind_gusts_10m?.[omIdx] ?? hourlyDataForStorage.wind_gusts_10m[metIdx];
                            hourlyDataForStorage.uv_index[metIdx] = omHourly.uv_index?.[omIdx] ?? hourlyDataForStorage.uv_index[metIdx];
                            hourlyDataForStorage.pressure_msl[metIdx] = omHourly.pressure_msl?.[omIdx] ?? hourlyDataForStorage.pressure_msl[metIdx];
                            hourlyDataForStorage.soil_temperature_0cm[metIdx] = omHourly.soil_temperature_0cm?.[omIdx] ?? hourlyDataForStorage.soil_temperature_0cm[metIdx];
                            hourlyDataForStorage.soil_moisture_0_1cm[metIdx] = omHourly.soil_moisture_0_1cm?.[omIdx] ?? hourlyDataForStorage.soil_moisture_0_1cm[metIdx];
                            if (omHourly.cloud_cover?.[omIdx] !== undefined && omHourly.cloud_cover?.[omIdx] !== null) {
                                hourlyDataForStorage.cloud_cover[metIdx] = omHourly.cloud_cover[omIdx];
                            }
                             if (omHourly.is_day?.[omIdx] !== undefined && omHourly.is_day?.[omIdx] !== null) { // Prefer OpenMeteo's is_day if available
                                hourlyDataForStorage.is_day[metIdx] = omHourly.is_day[omIdx];
                            }
                        }
                    });
                }
            }

            // Daily data: Completely from Open-Meteo as MET.no compact doesn't provide daily summaries
            const dailyDataForStorage = openMeteoData && openMeteoData.daily ? {
                time: openMeteoData.daily.time || [],
                weather_code: openMeteoData.daily.weather_code || [],
                temperature_2m_max: openMeteoData.daily.temperature_2m_max || [],
                temperature_2m_min: openMeteoData.daily.temperature_2m_min || [],
                apparent_temperature_max: openMeteoData.daily.apparent_temperature_max || [],
                apparent_temperature_min: openMeteoData.daily.apparent_temperature_min || [],
                sunrise: openMeteoData.daily.sunrise || [],
                sunset: openMeteoData.daily.sunset || [],
                uv_index_max: openMeteoData.daily.uv_index_max || [],
                uv_index_clear_sky_max: openMeteoData.daily.uv_index_clear_sky_max || [],
                precipitation_sum: openMeteoData.daily.precipitation_sum || [],
                rain_sum: openMeteoData.daily.rain_sum || [],
                showers_sum: openMeteoData.daily.showers_sum || [],
                snowfall_sum: openMeteoData.daily.snowfall_sum || [],
                precipitation_hours: openMeteoData.daily.precipitation_hours || [],
                precipitation_probability_max: openMeteoData.daily.precipitation_probability_max || [],
                wind_speed_10m_max: openMeteoData.daily.wind_speed_10m_max || [],
                wind_gusts_10m_max: openMeteoData.daily.wind_gusts_10m_max || [],
                wind_direction_10m_dominant: openMeteoData.daily.wind_direction_10m_dominant || [],
                shortwave_radiation_sum: openMeteoData.daily.shortwave_radiation_sum || [],
                et0_fao_evapotranspiration: openMeteoData.daily.et0_fao_evapotranspiration || []
            } : { // Default empty structure if Open-Meteo daily fails
                time: [], weather_code: [], temperature_2m_max: [], temperature_2m_min: [],
                apparent_temperature_max: [], apparent_temperature_min: [], sunrise: [], sunset: [], uv_index_max: [],
                uv_index_clear_sky_max: [], precipitation_sum: [], rain_sum: [], showers_sum: [], snowfall_sum: [],
                precipitation_hours: [], precipitation_probability_max: [], wind_speed_10m_max: [],
                wind_gusts_10m_max: [], wind_direction_10m_dominant: [], shortwave_radiation_sum: [], et0_fao_evapotranspiration: []
            };


            const dataToStore = {
                id: locationId,
                province: province,
                district: district,
                lat: lat,
                lon: lon,
                current: currentWeatherObjectForStorage,
                hourly: hourlyDataForStorage,
                daily: dailyDataForStorage, // Use Open-Meteo's daily data
                lastUpdated: new Date().toISOString(),
                rawMetData: metData // Store raw MET data for potential direct use or re-processing
            };

            const transaction = db.transaction(STORE_NAME, 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            store.put(dataToStore);
            
            return new Promise((resolve, reject) => {
                transaction.oncomplete = () => {
                    console.log(`Offline HTML: Data stored for ${locationId}`);
                    resolve(dataToStore);
                };
                transaction.onerror = (event) => {
                    console.error(`Offline HTML: Error storing data for ${locationId}:`, event.target.error);
                    reject(event.target.error);
                };
            });

        }

        function loadWeatherDataForLocation(province, district, lat, lon, isCurrentLocation = false) {
            const locationId = `${province}_${district}`;
            currentSelectedLocation = { province, district, lat, lon };
            localStorage.setItem('lastSelectedLocation_v3', JSON.stringify(currentSelectedLocation));

            if (!db) {
                console.warn("Offline HTML: DB not ready, trying to load later.");
                setTimeout(() => loadWeatherDataForLocation(province, district, lat, lon, isCurrentLocation), 500);
                return;
            }

            const transaction = db.transaction(STORE_NAME, 'readonly');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.get(locationId);

            request.onsuccess = (event) => {
                const data = event.target.result;
                if (data) {
                    console.log(`Offline HTML: Data loaded from DB for ${locationId}:`, data);
                    updateWeatherDisplay(data.current, data.hourly, data.daily, `${province} / ${district}`, data.lastUpdated, data.rawMetData);
                    if (isCurrentLocation) {
                        // Check if this current location data needs refresh from API (e.g., older than 1 hour)
                        const oneHour = 60 * 60 * 1000;
                        if (!data.lastUpdated || (Date.now() - new Date(data.lastUpdated).getTime()) > oneHour) {
                            console.log(`Offline HTML: Current location data for ${locationId} is old, refreshing from API.`);
                            fetchWeatherDataAndStore(province, district, lat, lon).then(freshData => {
                                if (freshData) updateWeatherDisplay(freshData.current, freshData.hourly, freshData.daily, `${province} / ${district}`, freshData.lastUpdated, freshData.rawMetData);
                            });
                        }
                    }
                } else {
                    console.log(`Offline HTML: No data in DB for ${locationId}, fetching from API...`);
                    resetWeatherDisplayToLoading(`${province} / ${district}`);
                    fetchWeatherDataAndStore(province, district, lat, lon).then(freshData => {
                        if (freshData) {
                             updateWeatherDisplay(freshData.current, freshData.hourly, freshData.daily, `${province} / ${district}`, freshData.lastUpdated, freshData.rawMetData);
                             updateDataProgressIndicator(); // Update count if new data added
                        } else {
                            updateWeatherDisplay(null, null, null, `${province} / ${district} (Veri Alınamadı)`);
                        }
                    });
                }
            };
            request.onerror = (event) => console.error(`Offline HTML: Error loading data for ${locationId}:`, event.target.error);
        }
        
        function updateOverallProgress(currentIndex, totalCount, currentAction) {
            const percentage = totalCount > 0 ? Math.round((currentIndex / totalCount) * 100) : 0;
            loadingText.textContent = `İller Güncelleniyor: ${currentIndex} / ${totalCount} (${currentAction})...`;
            progressBar.style.width = `${percentage}%`;
            progressBar.textContent = `${percentage}%`;
        }

        function hideLoading() {
            loadingContainer.style.display = 'none';
        }
        
        async function bulkUpdateAllProvincesData(forceUpdate = false) {
            if (provincesToFetchForBulkUpdate.length === 0) {
                console.log("Offline HTML: No provinces configured for bulk update.");
                hideLoading();
                updateDataProgressIndicator(); // Still update with current count
                return;
            }
            
            console.log(`Offline HTML: Starting bulk update. Force update: ${forceUpdate}`);
            loadingContainer.style.display = 'flex';
            loadingText.textContent = 'Toplu veri güncelleme işlemi başlatılıyor...';
            updateOverallProgress(0, provincesToFetchForBulkUpdate.length, "Başlatılıyor...");

            let anyDataActuallyFetchedAndStored = false;

            for (let i = 0; i < provincesToFetchForBulkUpdate.length; i++) {
                const loc = provincesToFetchForBulkUpdate[i];
                const locationId = `${loc.province}_${loc.district}`;
                updateOverallProgress(i + 1, provincesToFetchForBulkUpdate.length, `${loc.province}/${loc.district}`);
                
                try {
                    const storedData = await new Promise((resolve, reject) => {
                        if (!db) { reject("DB not ready"); return; }
                        const transaction = db.transaction(STORE_NAME, 'readonly');
                        const store = transaction.objectStore(STORE_NAME);
                        const request = store.get(locationId);
                        request.onsuccess = (event) => resolve(event.target.result);
                        request.onerror = (event) => reject(event.target.error);
                    });

                    const needsUpdate = !storedData || !storedData.lastUpdated || (Date.now() - new Date(storedData.lastUpdated).getTime()) > SIX_HOURS_MS;

                    if (forceUpdate || needsUpdate) {
                        console.log(`Offline HTML: Fetching for ${locationId} (Forced: ${forceUpdate}, Needs Update: ${needsUpdate})`);
                        const fetched = await fetchWeatherDataAndStore(loc.province, loc.district, loc.lat, loc.lon);
                        if (fetched) {
                            anyDataActuallyFetchedAndStored = true;
                        }
                    } else {
                        console.log(`Offline HTML: Data for ${locationId} is recent. Skipping API fetch.`);
                    }
                } catch (error) {
                    console.error(`Offline HTML: Error processing ${locationId} in bulk:`, error);
                }
                if (i < provincesToFetchForBulkUpdate.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, BULK_REQUEST_DELAY));
                }
            }
            
            if (anyDataActuallyFetchedAndStored) {
                 localStorage.setItem('lastBulkUpdateTime_v3', Date.now().toString());
                 console.log("Offline HTML: Bulk update completed. lastBulkUpdateTime_v3 set.");
            } else if (forceUpdate && !anyDataActuallyFetchedAndStored){
                 console.log("Offline HTML: Forced bulk update ran, but no new data was fetched/stored (all up to date or errors). Not updating lastBulkUpdateTime_v3.");
            } else {
                 console.log("Offline HTML: Bulk update check ran, no new data needed or fetched. Not updating lastBulkUpdateTime_v3.");
            }

            loadingText.textContent = 'Tüm veriler kontrol edildi.';
            setTimeout(() => { // Keep completion message for a bit
                hideLoading();
                // Refresh current view if it was one of the updated ones
                if (currentSelectedLocation.province && currentSelectedLocation.district) {
                     loadWeatherDataForLocation(currentSelectedLocation.province, currentSelectedLocation.district, currentSelectedLocation.lat, currentSelectedLocation.lon);
                }
            }, 1500);
            await updateDataProgressIndicator(); // Final update of the top indicator
        }


        function updateWeatherDisplay(currentWeatherData, hourlyData, dailyData, locationNameStr, lastUpdateTimeStr, rawMetData) {
            if (!currentWeatherData || !hourlyData || !dailyData) {
                locationNameEl.textContent = locationNameStr || "Veri Yok";
                currentTimeEl.textContent = "Güncelleme başarısız oldu.";
                temperatureEl.textContent = "--°C";
                weatherDescriptionEl.textContent = "Veri alınamadı.";
                weatherIconEl.src = DEFAULT_WEATHER_ICON;
                weatherIconEl.alt = "Veri Yok";
                feelsLikeEl.textContent = "--°C";
                humidityEl.textContent = "--%";
                windEl.textContent = "-- km/s";
                pressureEl.textContent = "-- hPa";
                visibilityEl.textContent = "-- km";
                uvIndexEl.textContent = "--";
                sunriseEl.textContent = "--:--";
                sunsetEl.textContent = "--:--";
                
                detailsLocationNameEl.textContent = locationNameStr || "";
                hourlyLocationNameEl.textContent = locationNameStr || "";
                dailyLocationNameEl.textContent = locationNameStr || "";
                alertsLocationNameEl.textContent = locationNameStr || "";
                mapLocationEl.textContent = `Harita için konum: ${locationNameStr || "Bilinmiyor"}`;

                detailsContainer.innerHTML = "<p>Bu konum için ayrıntılı veri bulunamadı.</p>";
                hourlyForecastContainer.innerHTML = "<p>Bu konum için saatlik tahmin bulunamadı.</p>";
                dailyForecastContainer.innerHTML = "<p>Bu konum için günlük tahmin bulunamadı.</p>";
                alertsContainer.innerHTML = "<p>Uyarılar kontrol edilemedi.</p>";
                updateMapTab(null,null, locationNameStr || "Bilinmiyor");
                return;
            }

            locationNameEl.textContent = locationNameStr;
            const lastUpdateDate = lastUpdateTimeStr ? new Date(lastUpdateTimeStr) : new Date(currentWeatherData.time);
            currentTimeEl.textContent = `Son Güncelleme: ${formatTime(lastUpdateDate)} (${timeSince(lastUpdateDate)} önce)`;

            const isDay = currentWeatherData.is_day === 1;
            weatherIconEl.src = getWeatherIconPath(currentWeatherData.weather_code, isDay);
            weatherIconEl.alt = getWeatherDescription(currentWeatherData.weather_code);
            temperatureEl.textContent = `${Math.round(currentWeatherData.temperature_2m)}°C`;
            weatherDescriptionEl.textContent = getWeatherDescription(currentWeatherData.weather_code);

            feelsLikeEl.textContent = currentWeatherData.apparent_temperature !== null && currentWeatherData.apparent_temperature !== undefined ? `${Math.round(currentWeatherData.apparent_temperature)}°C` : 'N/A';
            humidityEl.textContent = `${Math.round(currentWeatherData.relative_humidity_2m)}%`;
            windEl.textContent = `${(currentWeatherData.wind_speed_10m).toFixed(1)} km/s (${getWindDirection(currentWeatherData.wind_direction_10m)})`;
            pressureEl.textContent = `${Math.round(currentWeatherData.surface_pressure)} hPa`; // Using surface_pressure which MET provides as sea_level for compact
            visibilityEl.textContent = currentWeatherData.visibility !== null && currentWeatherData.visibility !== undefined ? `${(currentWeatherData.visibility / 1000).toFixed(1)} km` : 'N/A';
            uvIndexEl.textContent = currentWeatherData.uv_index !== null && currentWeatherData.uv_index !== undefined ? currentWeatherData.uv_index.toFixed(1) : 'N/A';
            
            // Daily data for sunrise/sunset - usually from Open-Meteo
            const todayDaily = dailyData.time.length > 0 ? dailyData : null; // Assuming first entry is today if available
            sunriseEl.textContent = todayDaily && todayDaily.sunrise?.[0] ? formatTime(new Date(todayDaily.sunrise[0])) : 'N/A';
            sunsetEl.textContent = todayDaily && todayDaily.sunset?.[0] ? formatTime(new Date(todayDaily.sunset[0])) : 'N/A';
            
            detailsLocationNameEl.textContent = locationNameStr;
            hourlyLocationNameEl.textContent = locationNameStr;
            dailyLocationNameEl.textContent = locationNameStr;
            alertsLocationNameEl.textContent = locationNameStr;
            mapLocationEl.textContent = `Harita: ${locationNameStr}`;

            updateDetailedInfo(currentWeatherData, hourlyData, dailyData, locationNameStr, lastUpdateTimeStr, rawMetData);
            updateHourlyForecast(hourlyData, locationNameStr);
            updateDailyForecast(dailyData, locationNameStr);
            updateAlerts(currentWeatherData, hourlyData, dailyData, rawMetData, locationNameStr);
            updateMapTab(currentSelectedLocation.lat, currentSelectedLocation.lon, locationNameStr);

            // Kademeli sıcaklık değişimi (eğer saatlik veri varsa ve bir sonraki saat farklıysa)
            if (hourlyData.time.length > 1 && hourlyData.temperature_2m.length > 1) {
                const currentHour = new Date(currentWeatherData.time).getHours();
                const nextHourDataIndex = hourlyData.time.findIndex(t => new Date(t).getHours() === (currentHour + 1) % 24 && new Date(t).getDate() === new Date(currentWeatherData.time).getDate() || (currentHour === 23 && new Date(t).getHours() === 0) );

                if (nextHourDataIndex !== -1 && hourlyData.temperature_2m[nextHourDataIndex] !== null) {
                    const tempCurrent = currentWeatherData.temperature_2m;
                    const tempNextHour = hourlyData.temperature_2m[nextHourDataIndex];
                    if (tempCurrent !== tempNextHour) {
                        gradualTemperatureUpdate(tempCurrent, tempNextHour, temperatureEl);
                    }
                }
            }
        }
        
        let tempIntervalId;
        function gradualTemperatureUpdate(startTemp, endTemp, element) {
            clearInterval(tempIntervalId);
            let currentTemp = startTemp;
            const diff = endTemp - startTemp;
            const steps = Math.abs(diff) * 10; // 0.1 degree steps
            if (steps === 0) return;
            const delay = (60 * 60 * 1000) / steps; // Distribute over an hour

            tempIntervalId = setInterval(() => {
                if ((diff > 0 && currentTemp >= endTemp) || (diff < 0 && currentTemp <= endTemp)) {
                    clearInterval(tempIntervalId);
                    currentTemp = endTemp; // Ensure it ends exactly
                } else {
                    currentTemp += (diff / steps);
                }
                element.textContent = `${Math.round(currentTemp * 10) / 10}°C`; // Show one decimal during transition
            }, delay);
        }


        function updateDetailedInfo(currentWeatherData, hourlyData, dailyData, locationName, lastUpdateTime, rawMetData) {
            const feelsLikeTemp = currentWeatherData.apparent_temperature !== null && currentWeatherData.apparent_temperature !== undefined ? Math.round(currentWeatherData.apparent_temperature) + '°C' : 'N/A';
            console.log(`Offline HTML: updateDetailedInfo - Apparent Temp for ${locationName}:`, currentWeatherData.apparent_temperature, `Displaying: ${feelsLikeTemp}`);

            const detailsHTML = `
                <div class="detail-card">
                    <h4>Sıcaklık</h4>
                    <p>Mevcut: ${Math.round(currentWeatherData.temperature_2m)}°C</p>
                    <p>Hissedilen: ${feelsLikeTemp}</p>
                </div>
                <div class="detail-card">
                    <h4>Rüzgar</h4>
                    <p>Yön: ${currentWeatherData.wind_direction_10m}° (${getWindDirection(currentWeatherData.wind_direction_10m)})</p>
                    <p>Hız: ${(currentWeatherData.wind_speed_10m).toFixed(1)} km/s</p>
                </div>
                <div class="detail-card">
                    <h4>Basınç & Nem</h4>
                    <p>Basınç: ${Math.round(currentWeatherData.surface_pressure)} hPa</p>
                    <p>Nem: ${Math.round(currentWeatherData.relative_humidity_2m)}%</p>
                </div>
            `;
            detailsContainer.innerHTML = detailsHTML;
        }


        function updateHourlyForecast(hourlyData, locationName) {
            hourlyForecastContainer.innerHTML = ''; // Clear previous
            if (!hourlyData || !hourlyData.time || hourlyData.time.length === 0) {
                hourlyForecastContainer.innerHTML = "<p>Saatlik tahmin verisi bulunamadı.</p>";
                return;
            }

            // Show next 24 hours
            const now = new Date();
            let count = 0;
            for (let i = 0; i < hourlyData.time.length && count < 24; i++) {
                const hourTime = new Date(hourlyData.time[i]);
                if (hourTime < now && i < hourlyData.time.length -1 ) continue; // Skip past hours unless it's the last one

                const item = document.createElement('div');
                item.className = 'hourly-item';
                const isDay = hourlyData.is_day ? (hourlyData.is_day[i] === 1) : (hourTime.getHours() >= 6 && hourTime.getHours() < 20);

                item.innerHTML = `
                    <div class="time">${formatTime(hourTime, true)}</div>
                    <img src="${getWeatherIconPath(hourlyData.weather_code[i], isDay)}" alt="${getWeatherDescription(hourlyData.weather_code[i])}" class="icon" data-ai-hint="weather ${getWeatherDescription(hourlyData.weather_code[i]).toLowerCase()}">
                    <div class="temp">${hourlyData.temperature_2m[i] !== null ? Math.round(hourlyData.temperature_2m[i]) : '--'}°C</div>
                    ${hourlyData.precipitation_probability && hourlyData.precipitation_probability[i] !== null ? `<div class="precip">Yağış: ${hourlyData.precipitation_probability[i]}%</div>` : ''}
                `;
                hourlyForecastContainer.appendChild(item);
                count++;
            }
        }

        function updateDailyForecast(dailyData, locationName) {
            dailyForecastContainer.innerHTML = ''; // Clear previous
             if (!dailyData || !dailyData.time || dailyData.time.length === 0) {
                dailyForecastContainer.innerHTML = "<p>Günlük tahmin verisi bulunamadı.</p>";
                return;
            }

            dailyData.time.slice(0, 7).forEach((dateStr, index) => { // Max 7 days
                const date = new Date(dateStr);
                // Adjust for potential timezone issues if dateStr is just YYYY-MM-DD
                const localDate = new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());

                const item = document.createElement('div');
                item.className = 'day-item';
                const isDay = true; // Daily forecast icons are typically day versions

                item.innerHTML = `
                    <div class="date-info">
                        <div class="date">${formatDay(localDate)}</div>
                        <div class="description text-xs">${getWeatherDescription(dailyData.weather_code[index])}</div>
                    </div>
                    <img src="${getWeatherIconPath(dailyData.weather_code[index], isDay)}" alt="${getWeatherDescription(dailyData.weather_code[index])}" class="icon" data-ai-hint="weather ${getWeatherDescription(dailyData.weather_code[index]).toLowerCase()}">
                    <div class="temps">${dailyData.temperature_2m_max[index] !== null ? Math.round(dailyData.temperature_2m_max[index]) : '--'}° / ${dailyData.temperature_2m_min[index] !== null ? Math.round(dailyData.temperature_2m_min[index]) : '--'}°C</div>
                `;
                dailyForecastContainer.appendChild(item);
            });
        }

        function updateAlerts(currentWeatherData, hourlyData, dailyData, rawMetData, locationName) {
            alertsContainer.innerHTML = ''; // Clear previous alerts
            const alerts = [];
            const now = new Date();

            // Check for active alerts from MET Norway 'event' or 'warning_panel' in raw data (if available in compact, unlikely)
            // This part is highly dependent on the exact structure of rawMetData if it contains alerts.
            // For compact MET.no, explicit alerts are usually not present. We infer from conditions.

            // Infer alerts from current/hourly data (next 24-48 hours)
            if (hourlyData && hourlyData.time) {
                for (let i = 0; i < hourlyData.time.length && i < 48; i++) { // Check next 48 hours
                    const hourTime = new Date(hourlyData.time[i]);
                    if (hourTime < now) continue;

                    const wmo = hourlyData.weather_code[i];
                    const precip = hourlyData.precipitation[i];
                    const windSpeed = hourlyData.wind_speed_10m[i]; // km/h
                    const windGust = hourlyData.wind_gusts_10m ? hourlyData.wind_gusts_10m[i] : 0; // km/h
                    const temp = hourlyData.temperature_2m[i];

                    if (wmo === 95 || wmo === 96 || wmo === 99) { // Thunderstorm, possibly with hail
                        alerts.push({ type: 'danger', text: `Saat ${formatTime(hourTime, true)} civarında gök gürültülü fırtına bekleniyor.` });
                    }
                    if (precip > 5 && (wmo === 65 || wmo === 82)) { // Heavy rain / heavy showers (5mm/hr as threshold)
                         alerts.push({ type: 'warning', text: `Saat ${formatTime(hourTime, true)} civarında şiddetli yağmur (>${precip.toFixed(1)}mm) bekleniyor.` });
                    }
                    if (windSpeed > 60 || windGust > 80) { // Strong wind (e.g. > 60 km/h) or strong gusts (>80 km/h)
                         alerts.push({ type: 'warning', text: `Saat ${formatTime(hourTime, true)} civarında kuvvetli rüzgar (${windSpeed.toFixed(0)} km/s, hamle ${windGust ? windGust.toFixed(0) : '--'} km/s) bekleniyor.` });
                    }
                    if (wmo === 75 && precip > 2) { // Heavy snow (e.g. >2cm/hr equivalent)
                        alerts.push({ type: 'warning', text: `Saat ${formatTime(hourTime, true)} civarında yoğun kar yağışı bekleniyor.` });
                    }
                }
            }
            
            // Display unique alerts
            const uniqueAlertTexts = new Set();
            alerts.forEach(alert => uniqueAlertTexts.add(alert.text));

            if (uniqueAlertTexts.size > 0) {
                uniqueAlertTexts.forEach(text => {
                    const alertData = alerts.find(a => a.text === text); // Get the type for the first occurrence
                    const alertDiv = document.createElement('div');
                    alertDiv.className = `alert alert-${alertData.type || 'info'}`;
                    alertDiv.textContent = text;
                    alertsContainer.appendChild(alertDiv);
                });
            } else {
                alertsContainer.innerHTML = '<p class="alert alert-info">Şu anda aktif meteorolojik uyarı bulunmamaktadır.</p>';
            }
        }

        function updateMapTab(lat, lon, locationName) {
            mapContainer.innerHTML = ''; // Clear previous map
            if (lat && lon) {
                const iframe = document.createElement('iframe');
                iframe.width = '100%';
                iframe.height = '100%';
                iframe.frameBorder = '0';
                iframe.style.border = '0';
                iframe.allowFullscreen = true;
                iframe.src = `https://maps.google.com/maps?q=${lat},${lon}&hl=tr&z=10&output=embed`;
                mapContainer.appendChild(iframe);
                mapLocationEl.textContent = `Harita: ${locationName}`;
            } else {
                mapContainer.innerHTML = '<p>Haritayı görüntülemek için bir konum seçin veya konum servisini kullanın.</p>';
                mapLocationEl.textContent = `Harita: Konum Seçilmedi`;
            }
        }
        
        function resetWeatherDisplayToLoading(locationText = "Konum Yükleniyor...") {
            locationNameEl.textContent = locationText;
            currentTimeEl.textContent = "--:--";
            weatherIconEl.src = DEFAULT_WEATHER_ICON;
            weatherIconEl.alt = "Yükleniyor";
            temperatureEl.textContent = "--°C";
            weatherDescriptionEl.textContent = "Yükleniyor...";
            feelsLikeEl.textContent = "--°C";
            humidityEl.textContent = "--%";
            windEl.textContent = "-- km/s";
            pressureEl.textContent = "-- hPa";
            visibilityEl.textContent = "-- km";
            uvIndexEl.textContent = "--";
            sunriseEl.textContent = "--:--";
            sunsetEl.textContent = "--:--";

            detailsLocationNameEl.textContent = locationText.split('(')[0].trim();
            hourlyLocationNameEl.textContent = locationText.split('(')[0].trim();
            dailyLocationNameEl.textContent = locationText.split('(')[0].trim();
            alertsLocationNameEl.textContent = locationText.split('(')[0].trim();
            mapLocationEl.textContent = `Harita için: ${locationText.split('(')[0].trim()}`;
            
            detailsContainer.innerHTML = "<p>Veriler yükleniyor...</p>";
            hourlyForecastContainer.innerHTML = "<p>Veriler yükleniyor...</p>";
            dailyForecastContainer.innerHTML = "<p>Veriler yükleniyor...</p>";
            alertsContainer.innerHTML = "<p>Veriler yükleniyor...</p>";
            updateMapTab(null, null, locationText.split('(')[0].trim());
        }

        // Helper functions
        function formatTime(date, showDay = false) {
            if (!(date instanceof Date)) date = new Date(date);
            const options = { hour: '2-digit', minute: '2-digit' };
            if (showDay) {
                options.weekday = 'short';
                return date.toLocaleTimeString('tr-TR', options);
            }
            return date.toLocaleTimeString('tr-TR', options);
        }

        function formatDay(date) {
            if (!(date instanceof Date)) date = new Date(date);
            const options = { weekday: 'long', day: 'numeric', month: 'short' };
            return date.toLocaleDateString('tr-TR', options);
        }

        function getWindDirection(degrees) {
            const directions = ['K', 'KKD', 'KD', 'DKD', 'D', 'DGD', 'GD', 'GGD', 'G', 'GGB', 'GB', 'BGB', 'B', 'BKB', 'KB', 'KKB'];
            return directions[Math.round(degrees / 22.5) % 16];
        }
        
        function timeSince(date) {
            if (!(date instanceof Date)) date = new Date(date);
            const seconds = Math.floor((new Date() - date) / 1000);
            let interval = seconds / 31536000;
            if (interval > 1) return Math.floor(interval) + " yıl";
            interval = seconds / 2592000;
            if (interval > 1) return Math.floor(interval) + " ay";
            interval = seconds / 86400;
            if (interval > 1) return Math.floor(interval) + " gün";
            interval = seconds / 3600;
            if (interval > 1) return Math.floor(interval) + " sa";
            interval = seconds / 60;
            if (interval > 1) return Math.floor(interval) + " dk";
            return Math.floor(seconds) + " sn";
        }

        // Event Listeners for Tabs
        document.querySelectorAll('.tab-button').forEach(button => {
            button.addEventListener('click', () => {
                document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                document.getElementById(button.dataset.tab + 'WeatherTab').classList.add('active'); // Main weather cards
                document.getElementById(button.dataset.tab + 'Tab').classList.add('active'); // Specific content tabs
            });
        });
        
        // Initialize: Populate province select and load last/default location
        async function loadDefaultOrLastSelectedLocation() {
            const lastSelected = JSON.parse(localStorage.getItem('lastSelectedLocation_v3'));
            if (lastSelected && lastSelected.province && lastSelected.district && lastSelected.lat !== undefined) {
                console.log("Offline HTML: Loading last selected location:", lastSelected);
                // Set select value
                const selectVal = `${lastSelected.province}|${lastSelected.district}|${lastSelected.lat}|${lastSelected.lon}`;
                if (Array.from(provinceSelect.options).some(opt => opt.value === selectVal)) {
                     provinceSelect.value = selectVal;
                } else { // If not in dropdown (e.g. not a main district), try to find a match or add it if it's a special one
                    const specialMatch = provincesToFetchForBulkUpdate.find(p => p.province === lastSelected.province && p.district === lastSelected.district);
                    if (specialMatch) { // If it's one of the specially added locations like Domaniç
                        provinceSelect.value = `${specialMatch.province}|${specialMatch.district}|${specialMatch.lat}|${specialMatch.lon}`;
                    } else { // Fallback to province's main district if direct match not found
                        const provinceMain = provincesToFetchForBulkUpdate.find(p => p.province === lastSelected.province && (p.district === "Merkez" || p.district === "Çankaya" /* add other main district names */));
                        if (provinceMain) provinceSelect.value = `${provinceMain.province}|${provinceMain.district}|${provinceMain.lat}|${provinceMain.lon}`;
                        else if (provinceSelect.options.length > 1) provinceSelect.selectedIndex = 1; // Fallback to first actual province
                    }
                }
                loadWeatherDataForLocation(lastSelected.province, lastSelected.district, lastSelected.lat, lastSelected.lon);
            } else { // Load Ankara as default if nothing else
                console.log("Offline HTML: No last selected location, loading default (Ankara).");
                const ankaraVal = "Ankara|Çankaya|39.9208|32.8541";
                if (Array.from(provinceSelect.options).some(opt => opt.value === ankaraVal)) {
                    provinceSelect.value = ankaraVal;
                } else if (provinceSelect.options.length > 1) {
                     provinceSelect.selectedIndex = 1; // Fallback
                }
                loadWeatherDataForLocation("Ankara", "Çankaya", 39.9208, 32.8541);
            }
        }

        // Province Select Event Listener
        provinceSelect.addEventListener('change', (e) => {
            const [province, district, lat, lon] = e.target.value.split('|');
            if (province && district && lat !== undefined && lon !== undefined) {
                resetWeatherDisplayToLoading(`${province} / ${district}`);
                loadWeatherDataForLocation(province, district, parseFloat(lat), parseFloat(lon));
            }
        });
        
        // Major Cities Button
        majorCitiesButton.addEventListener('click', () => {
            quickActionsCard.style.display = quickActionsCard.style.display === 'none' || quickActionsCard.style.display === '' ? 'block' : 'none';
        });

        // Quick Action Buttons for Major Cities
        document.querySelectorAll('.quick-action-btn').forEach(button => {
            button.addEventListener('click', () => {
                const province = button.dataset.province;
                const district = button.dataset.district;
                const locData = provincesToFetchForBulkUpdate.find(p => p.province === province && p.district === district);
                if (locData) {
                    provinceSelect.value = `${locData.province}|${locData.district}|${locData.lat}|${locData.lon}`; // Update dropdown
                    resetWeatherDisplayToLoading(`${locData.province} / ${locData.district}`);
                    loadWeatherDataForLocation(locData.province, locData.district, locData.lat, locData.lon);
                    quickActionsCard.style.display = 'none'; // Hide after selection
                }
            });
        });

        // Get Location Button
        getLocationButton.addEventListener('click', () => {
            if (navigator.geolocation) {
                resetWeatherDisplayToLoading("Konumunuz Alınıyor...");
                navigator.geolocation.getCurrentPosition(
                    async (position) => {
                        const lat = position.coords.latitude;
                        const lon = position.coords.longitude;
                        console.log(`Offline HTML: GPS Location: Lat ${lat}, Lon ${lon}`);
                        
                        // Find closest match from our list (simplistic)
                        let closest = null;
                        let minDist = Infinity;
                        provincesToFetchForBulkUpdate.forEach(loc => {
                            const dist = Math.sqrt(Math.pow(loc.lat - lat, 2) + Math.pow(loc.lon - lon, 2));
                            if (dist < minDist) {
                                minDist = dist;
                                closest = loc;
                            }
                        });

                        if (closest) {
                            console.log(`Offline HTML: Closest known location: ${closest.province}/${closest.district} (Distance: ${minDist.toFixed(4)})`);
                            provinceSelect.value = `${closest.province}|${closest.district}|${closest.lat}|${closest.lon}`;
                            loadWeatherDataForLocation(closest.province, closest.district, closest.lat, closest.lon, true); // true for isCurrentLocation
                        } else {
                            alert("En yakın bilinen konum bulunamadı.");
                            resetWeatherDisplayToLoading("Konum Bulunamadı");
                        }
                    },
                    (error) => {
                        console.error("Offline HTML: Geolocation error:", error);
                        alert(`Konum alınamadı: ${error.message}`);
                        resetWeatherDisplayToLoading("Konum Alınamadı");
                    },
                    { timeout: 10000, enableHighAccuracy: false }
                );
            } else {
                alert("Tarayıcınız konum servisini desteklemiyor.");
            }
        });
        
        // Force Refresh Button
        forceRefreshButton.addEventListener('click', () => {
            if (confirm("Tüm il verilerini API'den zorla yenilemek istediğinizden emin misiniz? Bu işlem biraz zaman alabilir ve mobil veri kullanıyorsanız veri tüketebilir.")) {
                localStorage.removeItem('lastBulkUpdateTime_v3'); // Clear timestamp to allow immediate re-fetch attempt
                bulkUpdateAllProvincesData(true); // true for force update
            }
        });


        // Initialize DB and load data on page load
        initDb();

    </script>
</body>
</html>

