<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HavaDurumuX - Çevrimdışı</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f8ff; /* Light AliceBlue */
            color: #333;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            margin: 0;
        }
        .header {
            background-color: #87CEEB; /* Sky Blue */
            color: white;
            padding: 1rem 0;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 1rem;
        }
        .header-title {
            font-size: 1.8rem;
            font-weight: bold;
        }
        .header-controls button, .header-controls select {
            margin-left: 0.5rem;
            font-size: 0.8rem;
            padding: 0.3rem 0.6rem;
        }
        .header-controls #dataProgressIndicator {
            background-color: rgba(255,255,255,0.2);
            padding: 0.3rem 0.7rem;
            border-radius: 0.25rem;
            font-size: 0.85rem;
            margin-left: 0.5rem;
            color: white;
            font-weight: 500;
        }

        .main-container {
            flex-grow: 1;
            padding: 1rem;
            max-width: 1000px;
            margin: 0 auto;
            width: 100%;
        }
        .weather-card {
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            margin-bottom: 1.5rem;
            overflow: hidden;
        }
        .weather-card-header {
            background-color: #E6E6FA; /* Soft Lavender */
            color: #555;
            padding: 0.8rem 1rem;
            border-bottom: 1px solid #ddd;
            font-size: 1.1rem;
            font-weight: 600;
        }
        .weather-card-body {
            padding: 1rem;
        }
        .current-weather-display {
            display: flex;
            align-items: center;
            justify-content: space-around;
            margin-bottom: 1rem;
        }
        .current-weather-display .temp {
            font-size: 3rem;
            font-weight: bold;
            color: #87CEEB;
        }
        .current-weather-display .condition-icon {
            font-size: 3.5rem;
            color: #87CEEB;
        }
        .current-weather-display .condition-text {
            font-size: 1rem;
            color: #555;
            text-align: center;
        }
        .detail-card {
            background-color: #f9f9f9;
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 0.8rem;
            text-align: center;
            margin-bottom: 0.5rem;
            font-size: 0.85rem;
        }
        .detail-card .value {
            font-weight: bold;
            font-size: 1rem;
            color: #87CEEB;
        }
        .forecast-tabs .nav-link {
            color: #87CEEB;
            font-weight: 500;
        }
        .forecast-tabs .nav-link.active {
            color: #555;
            background-color: #E6E6FA !important;
            border-color: #ddd #ddd #E6E6FA !important;
        }
        .daily-forecast-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.6rem 0.3rem;
            border-bottom: 1px solid #eee;
            font-size: 0.9rem;
        }
        .daily-forecast-item:last-child {
            border-bottom: none;
        }
        .daily-forecast-item .day {
            font-weight: 600;
        }
        .daily-forecast-item .icon {
            font-size: 1.5rem;
            color: #87CEEB;
        }
        .hourly-forecast-container {
            overflow-x: auto;
            white-space: nowrap;
            padding-bottom: 1rem;
        }
        .hourly-forecast-item {
            display: inline-block;
            width: 80px;
            text-align: center;
            padding: 0.5rem;
            margin-right: 0.5rem;
            border: 1px solid #eee;
            border-radius: 8px;
            background-color: #f9f9f9;
            font-size: 0.8rem;
        }
        .hourly-forecast-item .icon {
            font-size: 1.8rem;
            color: #87CEEB;
            margin-bottom: 0.2rem;
        }
        .loading-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1056; /* Higher than Bootstrap modals */
            font-size: 1.2rem;
        }
        .loading-container .spinner-border {
            width: 3rem;
            height: 3rem;
            margin-bottom: 1rem;
        }
        .quick-actions button {
            margin: 0.2rem;
            font-size: 0.8rem;
        }
        #mapContainer iframe {
            border: none;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .footer {
            text-align: center;
            padding: 1rem;
            background-color: #e0f0f8;
            color: #555;
            font-size: 0.85rem;
            margin-top: auto;
        }
        @media (max-width: 767px) {
            .header-content {
                flex-direction: column;
            }
            .header-title {
                margin-bottom: 0.5rem;
            }
            .header-controls {
                width: 100%;
                display: flex;
                justify-content: center;
                flex-wrap: wrap;
            }
            .header-controls > * { margin: 0.2rem; }
            .current-weather-display { flex-direction: column; }
            .current-weather-display .temp { margin-bottom: 0.5rem; font-size: 2.5rem; }
            .current-weather-display .condition-icon { font-size: 3rem; }
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="container header-content">
            <div class="header-title">HavaDurumuX Çevrimdışı</div>
            <div class="header-controls">
                <select id="provinceSelect" class="form-select form-select-sm d-inline-block" style="width: auto;"></select>
                <button id="forceRefreshButton" class="btn btn-light btn-sm" title="Mevcut konum verilerini anında yenile (API'den)">
                    <i class="fas fa-sync-alt"></i> Yenile
                </button>
                 <button id="forceBulkUpdateButton" class="btn btn-warning btn-sm" title="Tüm kayıtlı il verilerini API'den çekerek güncelle (6 saat bekleme süresini atlar)">
                    <i class="fas fa-database"></i> Tümünü API'den Yenile
                </button>
                <div id="dataProgressIndicator" title="Yerelde saklanan konum verisi sayısı / Toplam hedef konum sayısı">-- / --</div>
            </div>
        </div>
    </header>

    <div class="main-container container mt-3">
        <div id="loadingContainer" class="loading-container" style="display: none;">
            <div class="spinner-border text-light" role="status">
                <span class="visually-hidden">Yükleniyor...</span>
            </div>
            <p id="loadingMessage">Yükleniyor...</p>
        </div>

        <div class="row">
            <div class="col-md-8">
                <div class="weather-card">
                    <div class="weather-card-header" id="currentCity">Konum Seçin</div>
                    <div class="weather-card-body">
                        <div class="current-weather-display">
                            <div>
                                <div class="condition-icon"><i class="fas fa-question-circle"></i></div>
                                <div class="condition-text" id="currentCondition">--</div>
                            </div>
                            <div class="temp" id="currentTemp">--°C</div>
                        </div>
                        <div id="currentTimestamp" class="text-muted text-center small mb-3">Güncelleme: --</div>
                    </div>
                </div>

                <ul class="nav nav-tabs forecast-tabs" id="weatherTab" role="tablist">
                    <li class="nav-item" role="presentation">
                        <button class="nav-link active" id="details-tab" data-bs-toggle="tab" data-bs-target="#details" type="button" role="tab" aria-controls="details" aria-selected="true">Ayrıntılar</button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="hourly-tab" data-bs-toggle="tab" data-bs-target="#hourly" type="button" role="tab" aria-controls="hourly" aria-selected="false">Saatlik</button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="daily-tab" data-bs-toggle="tab" data-bs-target="#daily" type="button" role="tab" aria-controls="daily" aria-selected="false">Günlük Tahmin (Yaklaşık 3 Gün)</button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="alerts-tab" data-bs-toggle="tab" data-bs-target="#alerts" type="button" role="tab" aria-controls="alerts" aria-selected="false">Meteoroloji Uyarıları</button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="map-tab" data-bs-toggle="tab" data-bs-target="#map" type="button" role="tab" aria-controls="map" aria-selected="false">Harita</button>
                    </li>
                </ul>
                <div class="tab-content weather-card" id="weatherTabContent" style="border-top-left-radius: 0; border-top-right-radius: 0;">
                    <div class="tab-pane fade show active p-3" id="details" role="tabpanel" aria-labelledby="details-tab">
                        <h5>Ayrıntılı Bilgiler</h5>
                        <div id="detailsContainer" class="row">
                            <div class="col-md-4">
                                <div class="detail-card">Sıcaklık<div class="value" id="detailTempCurrent">--°C</div></div>
                                <div class="detail-card">Hissedilen<div class="value" id="detailTempApparent">--°C</div></div>
                            </div>
                            <div class="col-md-4">
                                <div class="detail-card">Rüzgar Yönü<div class="value" id="detailWindDir">--°</div></div>
                                <div class="detail-card">Rüzgar Hızı<div class="value" id="detailWindSpeed">-- km/s</div></div>
                            </div>
                            <div class="col-md-4">
                                <div class="detail-card">Basınç<div class="value" id="detailPressure">-- hPa</div></div>
                                <div class="detail-card">Nem<div class="value" id="detailHumidity">--%</div></div>
                            </div>
                        </div>
                    </div>
                    <div class="tab-pane fade p-3" id="hourly" role="tabpanel" aria-labelledby="hourly-tab">
                        <h5>Saatlik Tahmin (İlk 24 Saat)</h5>
                        <div id="hourlyForecastContainer" class="hourly-forecast-container">
                            <p class="text-muted">Saatlik tahmin verisi bulunamadı.</p>
                        </div>
                    </div>
                    <div class="tab-pane fade p-3" id="daily" role="tabpanel" aria-labelledby="daily-tab">
                        <h5>Günlük Tahmin (Mevcut API Verisiyle Sınırlı)</h5>
                        <div id="dailyForecastContainer">
                            <p class="text-muted">Günlük tahmin verisi bulunamadı.</p>
                        </div>
                    </div>
                    <div class="tab-pane fade p-3" id="alerts" role="tabpanel" aria-labelledby="alerts-tab">
                        <h5>Meteoroloji Uyarıları (<span id="alertLocationName"></span>)</h5>
                        <div id="alertsContainer">
                            <p class="text-muted">Aktif uyarı bulunmuyor.</p>
                        </div>
                    </div>
                    <div class="tab-pane fade p-3" id="map" role="tabpanel" aria-labelledby="map-tab">
                        <h5>Konum Haritası: <span id="mapLocation"></span></h5>
                        <div id="mapContainer" style="width: 100%; height: 400px;">
                            <p class="text-muted">Harita yüklenemedi. Lütfen bir konum seçin.</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="col-md-4">
                <div class="weather-card">
                    <div class="weather-card-header">Hızlı Eylemler</div>
                    <div class="weather-card-body quick-actions text-center">
                        <button id="getCurrentLocationBtn" class="btn btn-primary btn-sm mb-2 w-100"><i class="fas fa-location-arrow"></i> Mevcut Konumumu Bul</button>
                        <p class="text-muted small">Popüler İller:</p>
                        <button class="btn btn-outline-secondary btn-sm quick-city" data-city="Ankara">Ankara</button>
                        <button class="btn btn-outline-secondary btn-sm quick-city" data-city="İstanbul">İstanbul</button>
                        <button class="btn btn-outline-secondary btn-sm quick-city" data-city="İzmir">İzmir</button>
                        <button class="btn btn-outline-secondary btn-sm quick-city" data-city="Antalya">Antalya</button>
                        <button class="btn btn-outline-secondary btn-sm quick-city" data-city="Bursa">Bursa Merkez</button>
                        <button class="btn btn-outline-info btn-sm quick-city-special" data-city="Bursa" data-district="İnegöl">Bursa İnegöl</button>
                        <button class="btn btn-outline-secondary btn-sm quick-city" data-city="Kütahya">Kütahya Merkez</button>
                        <button class="btn btn-outline-info btn-sm quick-city-special" data-city="Kütahya" data-district="Domaniç">Kütahya Domaniç</button>
                    </div>
                </div>
                 <div class="weather-card mt-3">
                    <div class="weather-card-header">Veri Kaynağı & Güncelleme</div>
                    <div class="weather-card-body small">
                        <p>Bu sayfadaki veriler <a href="https://www.met.no/" target="_blank" rel="noopener noreferrer">MET Norway</a> tarafından sağlanmaktadır.</p>
                        <p>Veriler yaklaşık 6 saatte bir otomatik olarak güncellenmeye çalışılır. Manuel olarak "Tümünü API'den Yenile" butonu ile hemen güncelleme başlatabilirsiniz.</p>
                        <p>Son toplu güncelleme: <span id="lastBulkUpdateTimeDisplay" class="fw-bold">Hiçbir zaman</span></p>
                        <p>Bir sonraki otomatik güncelleme yaklaşık: <span id="nextBulkUpdateTimeDisplay" class="fw-bold">--</span></p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <footer class="footer">
        HavaDurumuX Çevrimdışı Sürümü &copy; <span id="currentYear"></span>
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // Constants
        const DB_NAME = 'HavaDurumuXOfflineDB_v3';
        const DB_VERSION = 2; // Increment version if schema changes
        const STORE_NAME = 'weatherData_v3';
        const MET_API_BASE_URL = 'https://api.met.no/weatherapi/locationforecast/2.0/compact';
        const MET_NORWAY_USER_AGENT = 'HavaDurumuXOffline/1.1 domaniccamlicakoyu@gmail.com';
        const BULK_REQUEST_DELAY = 5000; // 5 seconds
        const SIX_HOURS_MS = 6 * 60 * 60 * 1000;
        const CACHE_DURATION_MS = SIX_HOURS_MS; // How long to consider DB data fresh before re-fetch

        let db;
        let currentSelectedLocation = null; // { displayName, dbKey, lat, lon }
        let isBulkUpdating = false;
        let tempInterpolationInterval = null;

        // Utility to convert m/s to km/h
        const MPS_TO_KMH = 3.6;

        const provincesToFetchForBulkUpdate = [
            // Merkez ilçeler için koordinatlar yaklaşık değerlerdir.
            // Kütahya ve Bursa için hem merkez hem de özel ilçeler eklendi.
            { displayName: "Adana Merkez", dbKey: "Adana_Merkez", lat: 37.00, lon: 35.32 },
            { displayName: "Adıyaman Merkez", dbKey: "Adıyaman_Merkez", lat: 37.76, lon: 38.27 },
            { displayName: "Afyonkarahisar Merkez", dbKey: "Afyonkarahisar_Merkez", lat: 38.75, lon: 30.53 },
            { displayName: "Ağrı Merkez", dbKey: "Ağrı_Merkez", lat: 39.72, lon: 43.05 },
            { displayName: "Amasya Merkez", dbKey: "Amasya_Merkez", lat: 40.65, lon: 35.83 },
            { displayName: "Ankara Merkez", dbKey: "Ankara_Merkez", lat: 39.93, lon: 32.85 }, // Çankaya approx.
            { displayName: "Antalya Merkez", dbKey: "Antalya_Merkez", lat: 36.89, lon: 30.70 }, // Muratpaşa approx.
            { displayName: "Artvin Merkez", dbKey: "Artvin_Merkez", lat: 41.18, lon: 41.82 },
            { displayName: "Aydın Merkez", dbKey: "Aydın_Merkez", lat: 37.84, lon: 27.83 }, // Efeler approx.
            { displayName: "Balıkesir Merkez", dbKey: "Balıkesir_Merkez", lat: 39.65, lon: 27.88 }, // Karesi/Altıeylül approx.
            { displayName: "Bilecik Merkez", dbKey: "Bilecik_Merkez", lat: 40.14, lon: 29.98 },
            { displayName: "Bingöl Merkez", dbKey: "Bingöl_Merkez", lat: 38.88, lon: 40.49 },
            { displayName: "Bitlis Merkez", dbKey: "Bitlis_Merkez", lat: 38.40, lon: 42.11 },
            { displayName: "Bolu Merkez", dbKey: "Bolu_Merkez", lat: 40.73, lon: 31.61 },
            { displayName: "Burdur Merkez", dbKey: "Burdur_Merkez", lat: 37.72, lon: 30.28 },
            { displayName: "Bursa Merkez", dbKey: "Bursa_Merkez", lat: 40.18, lon: 29.06 }, // Osmangazi approx.
            { displayName: "Bursa İnegöl", dbKey: "Bursa_İnegöl", lat: 40.0833, lon: 29.5167 }, // Specific for İnegöl
            { displayName: "Çanakkale Merkez", dbKey: "Çanakkale_Merkez", lat: 40.15, lon: 26.41 },
            { displayName: "Çankırı Merkez", dbKey: "Çankırı_Merkez", lat: 40.60, lon: 33.61 },
            { displayName: "Çorum Merkez", dbKey: "Çorum_Merkez", lat: 40.55, lon: 34.95 },
            { displayName: "Denizli Merkez", dbKey: "Denizli_Merkez", lat: 37.77, lon: 29.09 }, // Merkezefendi/Pamukkale approx.
            { displayName: "Diyarbakır Merkez", dbKey: "Diyarbakır_Merkez", lat: 37.91, lon: 40.23 }, // Sur/Yenişehir approx.
            { displayName: "Edirne Merkez", dbKey: "Edirne_Merkez", lat: 41.67, lon: 26.57 },
            { displayName: "Elazığ Merkez", dbKey: "Elazığ_Merkez", lat: 38.67, lon: 39.22 },
            { displayName: "Erzincan Merkez", dbKey: "Erzincan_Merkez", lat: 39.74, lon: 39.49 },
            { displayName: "Erzurum Merkez", dbKey: "Erzurum_Merkez", lat: 39.90, lon: 41.27 }, // Yakutiye/Palandöken approx.
            { displayName: "Eskişehir Merkez", dbKey: "Eskişehir_Merkez", lat: 39.77, lon: 30.52 }, // Odunpazarı/Tepebaşı approx.
            { displayName: "Gaziantep Merkez", dbKey: "Gaziantep_Merkez", lat: 37.06, lon: 37.38 }, // Şahinbey/Şehitkamil approx.
            { displayName: "Giresun Merkez", dbKey: "Giresun_Merkez", lat: 40.91, lon: 38.39 },
            { displayName: "Gümüşhane Merkez", dbKey: "Gümüşhane_Merkez", lat: 40.46, lon: 39.47 },
            { displayName: "Hakkari Merkez", dbKey: "Hakkari_Merkez", lat: 37.57, lon: 43.74 },
            { displayName: "Hatay Merkez", dbKey: "Hatay_Merkez", lat: 36.20, lon: 36.16 }, // Antakya/Defne approx.
            { displayName: "Isparta Merkez", dbKey: "Isparta_Merkez", lat: 37.76, lon: 30.55 },
            { displayName: "Mersin Merkez", dbKey: "Mersin_Merkez", lat: 36.80, lon: 34.62 }, // Akdeniz/Yenişehir approx.
            { displayName: "İstanbul Merkez", dbKey: "İstanbul_Merkez", lat: 41.01, lon: 28.97 }, // Fatih approx. (çok geniş bir alan)
            { displayName: "İzmir Merkez", dbKey: "İzmir_Merkez", lat: 38.42, lon: 27.14 }, // Konak approx.
            { displayName: "Kars Merkez", dbKey: "Kars_Merkez", lat: 40.60, lon: 43.09 },
            { displayName: "Kastamonu Merkez", dbKey: "Kastamonu_Merkez", lat: 41.37, lon: 33.77 },
            { displayName: "Kayseri Merkez", dbKey: "Kayseri_Merkez", lat: 38.72, lon: 35.48 }, // Kocasinan/Melikgazi approx.
            { displayName: "Kırklareli Merkez", dbKey: "Kırklareli_Merkez", lat: 41.73, lon: 27.22 },
            { displayName: "Kırşehir Merkez", dbKey: "Kırşehir_Merkez", lat: 39.14, lon: 34.16 },
            { displayName: "Kocaeli Merkez", dbKey: "Kocaeli_Merkez", lat: 40.76, lon: 29.91 }, // İzmit approx.
            { displayName: "Konya Merkez", dbKey: "Konya_Merkez", lat: 37.87, lon: 32.48 }, // Selçuklu/Meram/Karatay approx.
            { displayName: "Kütahya Merkez", dbKey: "Kütahya_Merkez", lat: 39.42, lon: 29.98 },
            { displayName: "Kütahya Domaniç", dbKey: "Kütahya_Domaniç", lat: 39.8119, lon: 29.6078 }, // Specific for Domaniç
            { displayName: "Malatya Merkez", dbKey: "Malatya_Merkez", lat: 38.35, lon: 38.30 }, // Battalgazi/Yeşilyurt approx.
            { displayName: "Manisa Merkez", dbKey: "Manisa_Merkez", lat: 38.61, lon: 27.42 }, // Şehzadeler/Yunusemre approx.
            { displayName: "Kahramanmaraş Merkez", dbKey: "Kahramanmaraş_Merkez", lat: 37.58, lon: 36.93 }, // Onikişubat/Dulkadiroğlu approx.
            { displayName: "Mardin Merkez", dbKey: "Mardin_Merkez", lat: 37.31, lon: 40.73 }, // Artuklu approx.
            { displayName: "Muğla Merkez", dbKey: "Muğla_Merkez", lat: 37.21, lon: 28.36 }, // Menteşe approx.
            { displayName: "Muş Merkez", dbKey: "Muş_Merkez", lat: 38.73, lon: 41.49 },
            { displayName: "Nevşehir Merkez", dbKey: "Nevşehir_Merkez", lat: 38.62, lon: 34.71 },
            { displayName: "Niğde Merkez", dbKey: "Niğde_Merkez", lat: 37.96, lon: 34.68 },
            { displayName: "Ordu Merkez", dbKey: "Ordu_Merkez", lat: 40.98, lon: 37.88 }, // Altınordu approx.
            { displayName: "Rize Merkez", dbKey: "Rize_Merkez", lat: 41.02, lon: 40.52 },
            { displayName: "Sakarya Merkez", dbKey: "Sakarya_Merkez", lat: 40.77, lon: 30.40 }, // Adapazarı approx.
            { displayName: "Samsun Merkez", dbKey: "Samsun_Merkez", lat: 41.28, lon: 36.33 }, // İlkadım/Atakum/Canik approx.
            { displayName: "Siirt Merkez", dbKey: "Siirt_Merkez", lat: 37.93, lon: 41.94 },
            { displayName: "Sinop Merkez", dbKey: "Sinop_Merkez", lat: 42.02, lon: 35.15 },
            { displayName: "Sivas Merkez", dbKey: "Sivas_Merkez", lat: 39.75, lon: 37.01 },
            { displayName: "Tekirdağ Merkez", dbKey: "Tekirdağ_Merkez", lat: 40.98, lon: 27.51 }, // Süleymanpaşa approx.
            { displayName: "Tokat Merkez", dbKey: "Tokat_Merkez", lat: 40.32, lon: 36.55 },
            { displayName: "Trabzon Merkez", dbKey: "Trabzon_Merkez", lat: 41.00, lon: 39.72 }, // Ortahisar approx.
            { displayName: "Tunceli Merkez", dbKey: "Tunceli_Merkez", lat: 39.10, lon: 39.54 },
            { displayName: "Şanlıurfa Merkez", dbKey: "Şanlıurfa_Merkez", lat: 37.16, lon: 38.79 }, // Haliliye/Eyyübiye approx.
            { displayName: "Uşak Merkez", dbKey: "Uşak_Merkez", lat: 38.67, lon: 29.40 },
            { displayName: "Van Merkez", dbKey: "Van_Merkez", lat: 38.50, lon: 43.37 }, // İpekyolu/Tuşba approx.
            { displayName: "Yozgat Merkez", dbKey: "Yozgat_Merkez", lat: 39.82, lon: 34.80 },
            { displayName: "Zonguldak Merkez", dbKey: "Zonguldak_Merkez", lat: 41.45, lon: 31.79 },
            { displayName: "Aksaray Merkez", dbKey: "Aksaray_Merkez", lat: 38.36, lon: 34.03 },
            { displayName: "Bayburt Merkez", dbKey: "Bayburt_Merkez", lat: 40.25, lon: 40.22 },
            { displayName: "Karaman Merkez", dbKey: "Karaman_Merkez", lat: 37.18, lon: 33.21 },
            { displayName: "Kırıkkale Merkez", dbKey: "Kırıkkale_Merkez", lat: 39.84, lon: 33.51 },
            { displayName: "Batman Merkez", dbKey: "Batman_Merkez", lat: 37.88, lon: 41.13 },
            { displayName: "Şırnak Merkez", dbKey: "Şırnak_Merkez", lat: 37.51, lon: 42.46 },
            { displayName: "Bartın Merkez", dbKey: "Bartın_Merkez", lat: 41.63, lon: 32.33 },
            { displayName: "Ardahan Merkez", dbKey: "Ardahan_Merkez", lat: 41.11, lon: 42.70 },
            { displayName: "Iğdır Merkez", dbKey: "Iğdır_Merkez", lat: 39.92, lon: 44.04 },
            { displayName: "Yalova Merkez", dbKey: "Yalova_Merkez", lat: 40.65, lon: 29.27 },
            { displayName: "Karabük Merkez", dbKey: "Karabük_Merkez", lat: 41.20, lon: 32.62 },
            { displayName: "Kilis Merkez", dbKey: "Kilis_Merkez", lat: 36.71, lon: 37.11 },
            { displayName: "Osmaniye Merkez", dbKey: "Osmaniye_Merkez", lat: 37.07, lon: 36.24 },
            { displayName: "Düzce Merkez", dbKey: "Düzce_Merkez", lat: 40.84, lon: 31.15 }
        ];
        const TOTAL_TARGET_LOCATIONS = provincesToFetchForBulkUpdate.length;

        // DOM Elements
        const provinceSelect = document.getElementById('provinceSelect');
        const currentCityEl = document.getElementById('currentCity');
        const currentTempEl = document.getElementById('currentTemp');
        const currentConditionEl = document.getElementById('currentCondition');
        const currentConditionIconEl = document.querySelector('.current-weather-display .condition-icon i');
        const currentTimestampEl = document.getElementById('currentTimestamp');
        const detailsContainer = document.getElementById('detailsContainer');
        const hourlyForecastContainer = document.getElementById('hourlyForecastContainer');
        const dailyForecastContainer = document.getElementById('dailyForecastContainer');
        const alertsContainer = document.getElementById('alertsContainer');
        const alertLocationNameEl = document.getElementById('alertLocationName');
        const mapContainer = document.getElementById('mapContainer');
        const mapLocationEl = document.getElementById('mapLocation');
        const loadingContainer = document.getElementById('loadingContainer');
        const loadingMessageEl = document.getElementById('loadingMessage');
        const forceRefreshButton = document.getElementById('forceRefreshButton');
        const forceBulkUpdateButton = document.getElementById('forceBulkUpdateButton');
        const getCurrentLocationBtn = document.getElementById('getCurrentLocationBtn');
        const dataProgressIndicator = document.getElementById('dataProgressIndicator');
        const lastBulkUpdateTimeDisplay = document.getElementById('lastBulkUpdateTimeDisplay');
        const nextBulkUpdateTimeDisplay = document.getElementById('nextBulkUpdateTimeDisplay');


        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('currentYear').textContent = new Date().getFullYear();
            populateProvinceSelect();
            initDb();

            provinceSelect.addEventListener('change', handleProvinceSelectChange);
            forceRefreshButton.addEventListener('click', handleForceRefresh);
            forceBulkUpdateButton.addEventListener('click', handleForceBulkUpdate);
            getCurrentLocationBtn.addEventListener('click', handleGetCurrentLocation);
            
            document.querySelectorAll('.quick-city').forEach(button => {
                button.addEventListener('click', handleQuickCitySelect);
            });
            document.querySelectorAll('.quick-city-special').forEach(button => {
                button.addEventListener('click', handleQuickCitySpecialSelect);
            });

            // Load last selected location if available
            const lastSelectedDbKey = localStorage.getItem('lastSelectedLocationDbKey_v3');
            if (lastSelectedDbKey) {
                const foundLocation = provincesToFetchForBulkUpdate.find(p => p.dbKey === lastSelectedDbKey);
                if (foundLocation) {
                    currentSelectedLocation = foundLocation;
                    provinceSelect.value = foundLocation.dbKey; // Set dropdown
                }
            }
            // Default to Kütahya Merkez if nothing else is set
            if (!currentSelectedLocation && provincesToFetchForBulkUpdate.length > 0) {
                 const kütahyaMerkez = provincesToFetchForBulkUpdate.find(p => p.dbKey === "Kütahya_Merkez");
                 currentSelectedLocation = kütahyaMerkez || provincesToFetchForBulkUpdate[0];
                 provinceSelect.value = currentSelectedLocation.dbKey;
            }
        });

        function initDb() {
            showLoading('Veritabanı başlatılıyor...');
            const dbRequest = indexedDB.open(DB_NAME, DB_VERSION);

            dbRequest.onupgradeneeded = (event) => {
                console.log("Database upgrade needed.");
                db = (event.target).result;
                if (!db.objectStoreNames.contains(STORE_NAME)) {
                    db.createObjectStore(STORE_NAME, { keyPath: 'dbKey' });
                    console.log("Object store created:", STORE_NAME);
                }
            };

            dbRequest.onsuccess = (event) => {
                db = (event.target).result;
                console.log("Database opened successfully_v3.");
                updateDataProgressIndicator();
                
                // Load default or last viewed location first
                if (currentSelectedLocation) {
                    loadWeatherDataForLocation(currentSelectedLocation);
                } else if (provincesToFetchForBulkUpdate.length > 0) {
                     const kütahyaMerkez = provincesToFetchForBulkUpdate.find(p => p.dbKey === "Kütahya_Merkez");
                     currentSelectedLocation = kütahyaMerkez || provincesToFetchForBulkUpdate[0];
                     provinceSelect.value = currentSelectedLocation.dbKey;
                     loadWeatherDataForLocation(currentSelectedLocation);
                }


                // Check if bulk update is needed
                const lastBulkUpdateTimeString = localStorage.getItem('lastBulkUpdateTime_v3');
                let lastBulkUpdateTimeMs = 0;
                let shouldConsiderAutoBulkUpdate = true;

                if (lastBulkUpdateTimeString) {
                    lastBulkUpdateTimeMs = parseInt(lastBulkUpdateTimeString);
                    if (!isNaN(lastBulkUpdateTimeMs)) {
                        const timeSinceLastUpdate = Date.now() - lastBulkUpdateTimeMs;
                        console.log(`Last bulk update attempt completed at: ${new Date(lastBulkUpdateTimeMs).toLocaleString('tr-TR')} (Timestamp: ${lastBulkUpdateTimeMs})`);
                        console.log(`Time since last bulk update completion: ${formatTimeDifference(timeSinceLastUpdate)}`);
                        
                        if (timeSinceLastUpdate < SIX_HOURS_MS) {
                            shouldConsiderAutoBulkUpdate = false;
                            console.log(`AUTO BULK UPDATE NOT NEEDED. Last update was less than 6 hours ago. Next auto update in approx: ${formatTimeDifference(SIX_HOURS_MS - timeSinceLastUpdate)}`);
                            updateNextBulkUpdateDisplay(lastBulkUpdateTimeMs);
                            hideLoading(); // Ensure main loading is hidden
                        } else {
                            console.log("AUTO BULK UPDATE NEEDED: 6 hours passed since last update.");
                        }
                    } else {
                        console.warn("Invalid lastBulkUpdateTime_v3 found in localStorage. Will attempt auto bulk update.");
                        localStorage.removeItem('lastBulkUpdateTime_v3'); // Clean up invalid entry
                    }
                } else {
                    console.log("AUTO BULK UPDATE NEEDED: No lastBulkUpdateTime_v3 found in localStorage.");
                }
                updateLastBulkUpdateTimeDisplay();


                if (shouldConsiderAutoBulkUpdate) {
                    console.log("Calling bulkUpdateAllProvincesData(false) from initDb success because it's time or no prior update.");
                    bulkUpdateAllProvincesData(false); // isForced = false
                }
            };

            dbRequest.onerror = (event) => {
                console.error("Database error:", (event.target).error);
                showError("Veritabanı açılamadı. Çevrimdışı özellikler çalışmayabilir.");
                hideLoading();
            };
        }

        function populateProvinceSelect() {
            provincesToFetchForBulkUpdate.forEach(loc => {
                const option = document.createElement('option');
                option.value = loc.dbKey;
                option.textContent = loc.displayName;
                provinceSelect.appendChild(option);
            });
        }

        function handleProvinceSelectChange() {
            const selectedDbKey = provinceSelect.value;
            const selectedLoc = provincesToFetchForBulkUpdate.find(p => p.dbKey === selectedDbKey);
            if (selectedLoc) {
                currentSelectedLocation = selectedLoc;
                localStorage.setItem('lastSelectedLocationDbKey_v3', selectedLoc.dbKey);
                loadWeatherDataForLocation(selectedLoc);
            }
        }
        
        function handleQuickCitySelect(event) {
            const cityName = event.target.dataset.city;
            const targetLocation = provincesToFetchForBulkUpdate.find(p => p.displayName === cityName + " Merkez" || p.displayName === cityName); // Handle if " Merkez" is already in displayName
            if (targetLocation) {
                currentSelectedLocation = targetLocation;
                provinceSelect.value = targetLocation.dbKey;
                localStorage.setItem('lastSelectedLocationDbKey_v3', targetLocation.dbKey);
                loadWeatherDataForLocation(targetLocation);
            }
        }

        function handleQuickCitySpecialSelect(event) {
            const provinceName = event.target.dataset.city;
            const districtName = event.target.dataset.district;
            const targetLocation = provincesToFetchForBulkUpdate.find(p => p.displayName === `${provinceName} ${districtName}`);
            if (targetLocation) {
                currentSelectedLocation = targetLocation;
                provinceSelect.value = targetLocation.dbKey;
                localStorage.setItem('lastSelectedLocationDbKey_v3', targetLocation.dbKey);
                loadWeatherDataForLocation(targetLocation);
            }
        }


        function handleForceRefresh() {
            if (currentSelectedLocation) {
                console.log("Forcing refresh for current location:", currentSelectedLocation.displayName);
                fetchAndSaveWeatherData(currentSelectedLocation, true); // true to force API fetch
            } else {
                alert("Lütfen önce bir konum seçin.");
            }
        }
        
        function handleForceBulkUpdate() {
            console.log("Force bulk update triggered by button.");
            // The 'true' flag will bypass bulkUpdateAllProvincesData's internal time check.
            bulkUpdateAllProvincesData(true); 
        }
        
        function handleGetCurrentLocation() {
            showLoading("Mevcut konumunuz alınıyor...");
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(async (position) => {
                    const { latitude, longitude } = position.coords;
                    console.log("Geolocation success:", latitude, longitude);
                    // Find closest province from our list (simple proximity, not true reverse geocoding)
                    let closestLocation = null;
                    let minDistance = Infinity;

                    provincesToFetchForBulkUpdate.forEach(loc => {
                        const distance = getHaversineDistance(latitude, longitude, loc.lat, loc.lon);
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestLocation = loc;
                        }
                    });

                    if (closestLocation) {
                        console.log("Closest location found:", closestLocation.displayName, "Distance:", minDistance.toFixed(2), "km");
                        currentSelectedLocation = closestLocation;
                        provinceSelect.value = closestLocation.dbKey;
                        localStorage.setItem('lastSelectedLocationDbKey_v3', closestLocation.dbKey);
                        loadWeatherDataForLocation(closestLocation, true); // Force fetch for current location
                    } else {
                        showError("Size en yakın bilinen konum bulunamadı.");
                        hideLoading();
                    }
                }, (error) => {
                    console.error("Geolocation error:", error);
                    showError(`Konum alınamadı: ${error.message}`);
                    hideLoading();
                });
            } else {
                showError("Tarayıcınız konum servisini desteklemiyor.");
                hideLoading();
            }
        }

        async function loadWeatherDataForLocation(location, forceApiFetch = false) {
            if (!location || !location.dbKey) {
                console.error("Invalid location provided to loadWeatherDataForLocation:", location);
                updateWeatherDisplay(null, "Geçersiz Konum");
                return;
            }
            showLoading(`${location.displayName} için veri yükleniyor...`);
            const result = await fetchAndSaveWeatherData(location, forceApiFetch);
            
            if (result && result.data) {
                updateWeatherDisplay(result.data, location.displayName);
                updateDetailedInfo(result.data.properties.timeseries[0]);
                updateForecastTabs(result.data.properties.timeseries, location.displayName);
                updateAlerts(result.data.properties.timeseries, location.displayName);
                updateMapTab(location.lat, location.lon, location.displayName);
                 if (result.fromCache) {
                    console.log(`${location.displayName} data loaded from cache. Timestamp: ${new Date(result.data.timestamp).toLocaleString('tr-TR')}`);
                } else {
                    console.log(`${location.displayName} data fetched from API and saved. Timestamp: ${new Date(result.data.timestamp).toLocaleString('tr-TR')}`);
                }
            } else {
                console.error(`Failed to load weather data for ${location.displayName}.`);
                updateWeatherDisplay(null, location.displayName + " (Veri Alınamadı)");
                // Optionally try to load stale data if total failure
                 const staleData = await getWeatherDataFromDB(location.dbKey);
                 if (staleData) {
                    console.warn(`Displaying stale data for ${location.displayName} as a fallback.`);
                    updateWeatherDisplay(staleData, location.displayName + " (Eski Veri)");
                    updateDetailedInfo(staleData.properties.timeseries[0]);
                    updateForecastTabs(staleData.properties.timeseries, location.displayName);
                    updateAlerts(staleData.properties.timeseries, location.displayName);
                    updateMapTab(location.lat, location.lon, location.displayName);
                 }
            }
            hideLoading();
        }

        async function fetchAndSaveWeatherData(location, forceApi = false) {
            if (!db) {
                console.error("Database not initialized.");
                return null;
            }
             // Try to get from DB first
            if (!forceApi) {
                const dbData = await getWeatherDataFromDB(location.dbKey);
                if (dbData && dbData.timestamp && (Date.now() - dbData.timestamp < CACHE_DURATION_MS)) {
                    console.log(`Fresh data for ${location.displayName} found in DB.`);
                    return { data: dbData, fromCache: true };
                } else if (dbData) {
                    console.log(`Stale data for ${location.displayName} in DB. Will try API.`);
                } else {
                    console.log(`No data for ${location.displayName} in DB. Will try API.`);
                }
            } else {
                console.log(`Force API fetch for ${location.displayName}.`);
            }

            // Fetch from API
            try {
                console.log(`Fetching from MET API for ${location.displayName} (${location.lat}, ${location.lon})`);
                const response = await fetch(`${MET_API_BASE_URL}?lat=${location.lat}&lon=${location.lon}`, {
                    headers: { 'User-Agent': MET_NORWAY_USER_AGENT }
                });
                if (!response.ok) {
                    console.error(`API Error for ${location.displayName}: ${response.status} ${response.statusText}`);
                    const errorText = await response.text();
                    console.error("API Response Text:", errorText);
                    return { data: null, fromCache: false, error: `API Hatası: ${response.status}` };
                }
                const apiData = await response.json();
                if (apiData && apiData.properties && apiData.properties.timeseries) {
                    const dataToStore = { ...apiData, timestamp: Date.now(), dbKey: location.dbKey };
                    await saveWeatherDataToDB(dataToStore);
                    return { data: dataToStore, fromCache: false };
                } else {
                    console.error(`Invalid API data structure for ${location.displayName}:`, apiData);
                    return { data: null, fromCache: false, error: "Geçersiz API Verisi" };
                }
            } catch (error) {
                console.error(`Network or fetch error for ${location.displayName}:`, error);
                return { data: null, fromCache: false, error: "Ağ Hatası" };
            }
        }


        function getWeatherDataFromDB(dbKey) {
            return new Promise((resolve, reject) => {
                if (!db) { reject("DB not open"); return; }
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.get(dbKey);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => {
                    console.error("Error reading from DB:", request.error);
                    reject(request.error);
                };
            });
        }

        function saveWeatherDataToDB(data) {
            return new Promise((resolve, reject) => {
                if (!db) { reject("DB not open"); return; }
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.put(data); // put will add or update
                request.onsuccess = () => {
                    console.log(`Data for ${data.dbKey} saved to DB successfully.`);
                    resolve(request.result);
                };
                request.onerror = () => {
                    console.error("Error writing to DB:", request.error);
                    reject(request.error);
                };
            });
        }
        
        async function updateDataProgressIndicator() {
            if (!db) {
                dataProgressIndicator.textContent = 'Veritabanı Yok';
                return;
            }
            let count = 0;
            try {
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const countRequest = store.count();
                countRequest.onsuccess = () => {
                    // This counts all items in the store, not just those in our target list
                    // For a more accurate "X / 83", we'd need to iterate or check keys.
                    // For now, let's assume most stored items are from our target list.
                    // A more precise count:
                    let relevantCount = 0;
                    const keyRequest = store.getAllKeys();
                    keyRequest.onsuccess = () => {
                        const allKeysInDb = keyRequest.result;
                        provincesToFetchForBulkUpdate.forEach(targetLoc => {
                            if (allKeysInDb.includes(targetLoc.dbKey)) {
                                relevantCount++;
                            }
                        });
                        dataProgressIndicator.textContent = `Veri: ${relevantCount} / ${TOTAL_TARGET_LOCATIONS}`;
                    };
                    keyRequest.onerror = () => {
                         dataProgressIndicator.textContent = `Veri: ? / ${TOTAL_TARGET_LOCATIONS}`;
                    }
                };
                countRequest.onerror = () => {
                    dataProgressIndicator.textContent = `Veri: Hata / ${TOTAL_TARGET_LOCATIONS}`;
                };
            } catch (error) {
                console.error("Error updating data progress indicator:", error);
                dataProgressIndicator.textContent = 'Veri Durumu: Hata';
            }
        }


        async function bulkUpdateAllProvincesData(forceUpdate = false) {
            if (isBulkUpdating) {
                console.log("Bulk update already in progress.");
                if (loadingMessageEl.textContent.includes("tamamlandı") || loadingMessageEl.textContent.includes("bekleniyor")) {
                    // If a previous message indicated completion or waiting, but isBulkUpdating is still true,
                    // it might be a stuck state. Try to reset.
                     console.warn("isBulkUpdating was true but message suggested completion. Resetting flag.");
                     isBulkUpdating = false;
                } else {
                    return;
                }
            }
            
            const lastBulkUpdateTimeString = localStorage.getItem('lastBulkUpdateTime_v3');
            if (!forceUpdate && lastBulkUpdateTimeString) {
                const lastBulkUpdateTimeMs = parseInt(lastBulkUpdateTimeString);
                if (!isNaN(lastBulkUpdateTimeMs) && (Date.now() - lastBulkUpdateTimeMs) < SIX_HOURS_MS) {
                    console.log(`AUTO BULK UPDATE SKIPPED (by bulkUpdateAllProvincesData). Last update was less than 6 hours ago. Next auto update in approx: ${formatTimeDifference(SIX_HOURS_MS - (Date.now() - lastBulkUpdateTimeMs))}`);
                    updateNextBulkUpdateDisplay(lastBulkUpdateTimeMs);
                    // If loadWeatherDataForLocation for default city already hid its loading, we are fine.
                    // If this function was called and it decides to skip, ensure any general loading message is gone.
                    if (!document.getElementById('loadingContainer').style.display.includes('none')) {
                        hideLoading(); // Hide general loading if it was somehow still visible
                    }
                    return;
                }
            }

            console.log(forceUpdate ? "FORCED bulk update starting." : "AUTOMATIC bulk update starting (6 hours passed or no previous update).");
            isBulkUpdating = true;
            let updatedSomethingInBulk = false;
            let successfulUpdates = 0;
            let failedUpdates = 0;
            const totalToUpdate = provincesToFetchForBulkUpdate.length;

            showLoading(`Toplu güncelleme başlatılıyor (0/${totalToUpdate})...`);
            updateLastBulkUpdateTimeDisplay(); // Show current status

            for (let i = 0; i < totalToUpdate; i++) {
                const locationToProcess = provincesToFetchForBulkUpdate[i];
                updateLoadingMessage(`İller Güncelleniyor: ${i + 1} / ${totalToUpdate} (Şu an: ${locationToProcess.displayName})...`);
                
                const result = await fetchAndSaveWeatherData(locationToProcess, forceUpdate); // Pass forceUpdate down
                if (result) {
                    if (!result.fromCache && result.data) { // API fetch was successful
                        updatedSomethingInBulk = true;
                        successfulUpdates++;
                    } else if (result.fromCache && result.data) {
                        console.log(`${locationToProcess.displayName} data was from recent DB cache during bulk.`);
                        // Not an API update, but data is present
                    } else { // result.data is null (fetch failed)
                        console.error(`Bulk update failed for ${locationToProcess.displayName}. Error: ${result.error || 'Unknown'}`);
                        failedUpdates++;
                    }
                } else { // fetchAndSaveWeatherData itself had an issue (e.g., DB error before API call)
                     console.error(`Bulk update failed critically for ${locationToProcess.displayName}.`);
                    failedUpdates++;
                }

                if (i < totalToUpdate - 1) {
                    await new Promise(resolve => setTimeout(resolve, BULK_REQUEST_DELAY));
                }
            }
            
            isBulkUpdating = false;
            let summaryMessage = `Toplu güncelleme tamamlandı. Başarılı API güncellemesi: ${successfulUpdates}, Başarısız: ${failedUpdates}.`;
            if (updatedSomethingInBulk) {
                localStorage.setItem('lastBulkUpdateTime_v3', Date.now().toString());
                console.log("Bulk update finished. Last update time saved:", new Date(Date.now()).toLocaleString('tr-TR'));
                summaryMessage += " Son güncelleme zamanı kaydedildi.";
                 if (currentSelectedLocation) { // Reload current view with potentially new data
                    loadWeatherDataForLocation(currentSelectedLocation, false); // Don't force API, let it use fresh DB data
                }
            } else if (successfulUpdates === 0 && failedUpdates === totalToUpdate && totalToUpdate > 0) {
                summaryMessage += " Tüm konumlar için API'den veri alınamadı. Son güncelleme zamanı değiştirilmedi.";
                console.log("Bulk update attempted but all locations failed to update from API. Last update time not changed.");
            } else if (totalToUpdate > 0 && !updatedSomethingInBulk && successfulUpdates === 0 && failedUpdates === 0) {
                summaryMessage += " Tüm veriler günceldi (DB önbelleğinden). Son güncelleme zamanı değiştirilmedi.";
                 console.log("Bulk update ran, but all data was already fresh in DB cache. Last update time not changed.");
            } else {
                summaryMessage += " API'den yeni veri alınmadı. Son güncelleme zamanı değiştirilmedi.";
                console.log("Bulk update completed, but no new data was fetched from API (e.g., all from cache or all failed). Last update time not changed.");
            }
            
            console.log(summaryMessage);
            showLoading(summaryMessage, 3000); // Show for 3 seconds
            // hideLoading() will be called by showLoading after delay
            updateDataProgressIndicator();
            updateLastBulkUpdateTimeDisplay();
            updateNextBulkUpdateDisplay(localStorage.getItem('lastBulkUpdateTime_v3') ? parseInt(localStorage.getItem('lastBulkUpdateTime_v3')) : null);
        }


        function updateWeatherDisplay(data, cityName) {
            clearInterval(tempInterpolationInterval); // Clear any existing interval

            if (!data || !data.properties || !data.properties.timeseries || data.properties.timeseries.length === 0) {
                currentCityEl.textContent = cityName || "Bilinmeyen Konum";
                currentTempEl.textContent = "--°C";
                currentConditionEl.textContent = "Veri Yok";
                currentConditionIconEl.className = 'fas fa-question-circle';
                currentTimestampEl.textContent = `Güncelleme: ${new Date().toLocaleTimeString('tr-TR')}`;
                updateDetailedInfo(null);
                updateForecastTabs(null, cityName);
                updateAlerts(null, cityName);
                updateMapTab(null, null, cityName);
                return;
            }

            const currentTimeSeries = data.properties.timeseries[0];
            const weatherDetails = currentTimeSeries.data.instant.details;
            const next1HourSummary = currentTimeSeries.data.next_1_hours ? currentTimeSeries.data.next_1_hours.summary : null;
            const next1HourDetails = currentTimeSeries.data.next_1_hours ? currentTimeSeries.data.next_1_hours.details : null;


            currentCityEl.textContent = cityName;
            
            const currentApiTemp = parseFloat(weatherDetails.air_temperature);
            currentTempEl.textContent = `${Math.round(currentApiTemp)}°C`; // Initial display

            // Interpolation logic
            const nextHourData = data.properties.timeseries.find(ts => {
                const seriesTime = new Date(ts.time).getTime();
                const currentTime = new Date(currentTimeSeries.time).getTime();
                return seriesTime > currentTime && seriesTime <= currentTime + 3600 * 1000 * 1.5; // Look for next hour's data
            });

            if (nextHourData) {
                const nextApiTemp = parseFloat(nextHourData.data.instant.details.air_temperature);
                const tempDiff = nextApiTemp - currentApiTemp;
                const now = new Date();
                const currentSeriesTime = new Date(currentTimeSeries.time);
                const minutesIntoHour = (now.getTime() - currentSeriesTime.getTime()) / (60 * 1000);
                
                let interpolatedTemp = currentApiTemp + (tempDiff / 60) * minutesIntoHour;
                currentTempEl.textContent = `${interpolatedTemp.toFixed(1)}°C`;

                const updatesPerMinute = 2; // Update twice a minute for smoother transition (0.1C every 30s for 6C/hr diff)
                const intervalDuration = (60 / updatesPerMinute) * 1000; // in ms
                
                tempInterpolationInterval = setInterval(() => {
                    const currentMinutes = (new Date().getTime() - new Date(currentTimeSeries.time).getTime()) / (60 * 1000);
                    if (currentMinutes >= 60) { // Past the hour, stop and rely on next full data
                        clearInterval(tempInterpolationInterval);
                        // Potentially re-fetch or use nextHourData directly if logic desires
                        currentTempEl.textContent = `${Math.round(nextApiTemp)}°C`; 
                        return;
                    }
                    interpolatedTemp = currentApiTemp + (tempDiff / 60) * currentMinutes;
                    currentTempEl.textContent = `${interpolatedTemp.toFixed(1)}°C`;
                }, intervalDuration);
            }


            const symbolCode = next1HourSummary ? next1HourSummary.symbol_code : (currentTimeSeries.data.next_6_hours ? currentTimeSeries.data.next_6_hours.summary.symbol_code : 'unknown');
            const { description, Icon } = getWeatherSymbolInfo(symbolCode, new Date(currentTimeSeries.time));
            currentConditionEl.textContent = description;
            currentConditionIconEl.className = Icon; // Assuming Icon is a FontAwesome class string

            const lastUpdated = data.timestamp ? new Date(data.timestamp) : new Date();
            currentTimestampEl.textContent = `Veri Zamanı: ${new Date(currentTimeSeries.time).toLocaleTimeString('tr-TR', { hour: '2-digit', minute: '2-digit' })} | Saklandı: ${lastUpdated.toLocaleTimeString('tr-TR', { hour: '2-digit', minute: '2-digit' })}`;
        }

        function updateDetailedInfo(timeseriesEntry) {
            const na = "N/A";
            if (!timeseriesEntry || !timeseriesEntry.data || !timeseriesEntry.data.instant || !timeseriesEntry.data.instant.details) {
                document.getElementById('detailTempCurrent').textContent = `${na}°C`;
                document.getElementById('detailTempApparent').textContent = `${na}°C`;
                document.getElementById('detailWindDir').textContent = `${na}°`;
                document.getElementById('detailWindSpeed').textContent = `${na} km/s`;
                document.getElementById('detailPressure').textContent = `${na} hPa`;
                document.getElementById('detailHumidity').textContent = `${na}%`;
                return;
            }

            const details = timeseriesEntry.data.instant.details;
            const next1Hour = timeseriesEntry.data.next_1_hours?.details;

            // Mevcut Sıcaklık
            document.getElementById('detailTempCurrent').textContent = details.air_temperature !== undefined ? `${details.air_temperature.toFixed(1)}°C` : `${na}°C`;
            
            // Hissedilen Sıcaklık (Eğer MET.no API'den gelmiyorsa, Open-Meteo'dan alınabilir veya basit bir hesaplama yapılabilir - şimdilik N/A)
            // Bu çevrimdışı sürümde MET.no compact'ta 'apparent_temperature' yok.
             document.getElementById('detailTempApparent').textContent = `${na}°C`; // MET.no compact doesn't provide this directly for instant

            // Rüzgar Yönü ve Hızı
            document.getElementById('detailWindDir').textContent = details.wind_from_direction !== undefined ? `${details.wind_from_direction.toFixed(0)}°` : `${na}°`;
            document.getElementById('detailWindSpeed').textContent = details.wind_speed !== undefined ? `${(details.wind_speed * MPS_TO_KMH).toFixed(1)} km/s` : `${na} km/s`;

            // Basınç ve Nem
            document.getElementById('detailPressure').textContent = details.air_pressure_at_sea_level !== undefined ? `${details.air_pressure_at_sea_level.toFixed(0)} hPa` : `${na} hPa`;
            document.getElementById('detailHumidity').textContent = details.relative_humidity !== undefined ? `${details.relative_humidity.toFixed(0)}%` : `${na}%`;
        }


        function updateForecastTabs(timeseries, cityName) {
            alertLocationNameEl.textContent = cityName || "Seçili Konum";
            if (!timeseries || timeseries.length === 0) {
                hourlyForecastContainer.innerHTML = '<p class="text-muted">Saatlik tahmin verisi bulunamadı.</p>';
                dailyForecastContainer.innerHTML = '<p class="text-muted">Günlük tahmin verisi bulunamadı.</p>';
                return;
            }

            // Hourly Forecast (first 24 entries or less if data is shorter)
            let hourlyHtml = '';
            const hourlyToShow = Math.min(timeseries.length, 24);
            for (let i = 0; i < hourlyToShow; i++) {
                const entry = timeseries[i];
                const time = new Date(entry.time);
                const symbolInfo = getWeatherSymbolInfo(entry.data.next_1_hours?.summary.symbol_code || entry.data.next_6_hours?.summary.symbol_code, time);
                hourlyHtml += `
                    <div class="hourly-forecast-item">
                        <div>${time.getHours()}:00</div>
                        <div class="icon"><i class="${symbolInfo.Icon}"></i></div>
                        <div>${entry.data.instant.details.air_temperature.toFixed(0)}°C</div>
                        <div class="text-muted small">${(entry.data.next_1_hours?.details.precipitation_amount || 0).toFixed(1)}mm</div>
                    </div>
                `;
            }
            hourlyForecastContainer.innerHTML = hourlyHtml || '<p class="text-muted">Saatlik tahmin verisi yok.</p>';

            // Daily Forecast (aggregated from hourly)
            const dailyAggregated = {};
            timeseries.forEach(entry => {
                const dateStr = new Date(entry.time).toISOString().split('T')[0];
                if (!dailyAggregated[dateStr]) {
                    dailyAggregated[dateStr] = {
                        temps: [],
                        precip: 0,
                        codes: [],
                        date: new Date(entry.time)
                    };
                }
                dailyAggregated[dateStr].temps.push(entry.data.instant.details.air_temperature);
                dailyAggregated[dateStr].precip += (entry.data.next_1_hours?.details.precipitation_amount || 0);
                dailyAggregated[dateStr].codes.push(entry.data.next_1_hours?.summary.symbol_code || entry.data.next_6_hours?.summary.symbol_code);
            });

            let dailyHtml = '';
            const sortedDays = Object.keys(dailyAggregated).sort().slice(0, 7); // Max 7 days shown

            sortedDays.forEach(dateStr => {
                const dayData = dailyAggregated[dateStr];
                const maxTemp = Math.max(...dayData.temps);
                const minTemp = Math.min(...dayData.temps);
                // Determine dominant weather icon for the day (simple approach: most frequent)
                const codeCounts = dayData.codes.reduce((acc, code) => {
                    acc[code] = (acc[code] || 0) + 1;
                    return acc;
                }, {});
                let dominantCode = dayData.codes[0];
                let maxCount = 0;
                for (const code in codeCounts) {
                    if (codeCounts[code] > maxCount) {
                        maxCount = codeCounts[code];
                        dominantCode = code;
                    }
                }
                const symbolInfo = getWeatherSymbolInfo(dominantCode, dayData.date);
                const dayName = dayData.date.toLocaleDateString('tr-TR', { weekday: 'short' });

                dailyHtml += `
                    <div class="daily-forecast-item">
                        <span class="day">${dayName}, ${dayData.date.toLocaleDateString('tr-TR', {day: '2-digit', month:'short'})}</span>
                        <span class="icon"><i class="${symbolInfo.Icon}"></i></span>
                        <span>${minTemp.toFixed(0)}° / ${maxTemp.toFixed(0)}°C</span>
                        <span class="text-muted small">${dayData.precip.toFixed(1)}mm</span>
                    </div>
                `;
            });
            dailyForecastContainer.innerHTML = dailyHtml || '<p class="text-muted">Günlük tahmin verisi yok.</p>';
        }
        
        function updateAlerts(timeseries, cityName) {
            alertsContainer.innerHTML = ''; // Clear previous alerts
            if (!timeseries || timeseries.length === 0) {
                alertsContainer.innerHTML = '<p class="text-muted">Uyarı bilgisi için veri bulunamadı.</p>';
                return;
            }

            const alertsFound = [];
            // Check next 24-48 hours (up to ~48 entries if hourly)
            const lookAheadHours = Math.min(timeseries.length, 48);

            for (let i = 0; i < lookAheadHours; i++) {
                const entry = timeseries[i];
                const time = new Date(entry.time);
                const details = entry.data.instant.details;
                const next1HourDetails = entry.data.next_1_hours?.details;
                const symbolCode = entry.data.next_1_hours?.summary.symbol_code;

                // Example Alert Conditions (customize as needed)
                if (next1HourDetails && next1HourDetails.precipitation_amount > 10) { // Heavy rain > 10mm/hr
                    alertsFound.push({
                        time: time.toLocaleString('tr-TR'),
                        type: 'Şiddetli Yağmur Uyarısı',
                        message: `Saat ${time.getHours()}:00 civarında ${next1HourDetails.precipitation_amount.toFixed(1)}mm şiddetli yağmur bekleniyor.`,
                        severity: 'danger'
                    });
                }
                if (details.wind_speed * MPS_TO_KMH > 60) { // Strong wind > 60 km/h
                     alertsFound.push({
                        time: time.toLocaleString('tr-TR'),
                        type: 'Kuvvetli Rüzgar Uyarısı',
                        message: `Saat ${time.getHours()}:00 civarında rüzgar hızı ${(details.wind_speed * MPS_TO_KMH).toFixed(0)} km/s'e ulaşabilir.`,
                        severity: 'warning'
                    });
                }
                if (symbolCode && (symbolCode.includes(' लड़ाई') || symbolCode.includes('thunder'))) { // Thunderstorm
                    alertsFound.push({
                        time: time.toLocaleString('tr-TR'),
                        type: 'Gök Gürültülü Fırtına Uyarısı',
                        message: `Saat ${time.getHours()}:00 civarında gök gürültülü fırtına riski.`,
                        severity: 'danger'
                    });
                }
            }

            if (alertsFound.length > 0) {
                alertsFound.forEach(alert => {
                    const alertDiv = document.createElement('div');
                    alertDiv.className = `alert alert-${alert.severity} alert-dismissible fade show small p-2 mb-2`;
                    alertDiv.role = 'alert';
                    alertDiv.innerHTML = `
                        <strong>${alert.type}</strong> (${alert.time}): ${alert.message}
                        <button type="button" class="btn-close btn-sm p-2" data-bs-dismiss="alert" aria-label="Close"></button>
                    `;
                    alertsContainer.appendChild(alertDiv);
                });
            } else {
                alertsContainer.innerHTML = '<p class="text-muted">Aktif meteorolojik uyarı bulunmuyor.</p>';
            }
        }

        function updateMapTab(lat, lon, locationName) {
            mapLocationEl.textContent = locationName || "Bilinmiyor";
            if (lat && lon) {
                mapContainer.innerHTML = `<iframe src="https://maps.google.com/maps?q=${lat},${lon}&hl=tr&z=10&output=embed" width="100%" height="100%"></iframe>`;
            } else {
                mapContainer.innerHTML = '<p class="text-muted">Harita için konum bilgisi bulunamadı.</p>';
            }
        }

        function getWeatherSymbolInfo(symbolCode, date = new Date()) {
            // Simplified mapping from MET Norway symbol codes to Font Awesome icons
            // Refer to: https://api.met.no/weatherapi/weathericon/2.0/documentation
            const code = symbolCode ? symbolCode.toLowerCase() : 'unknown';
            const hour = date.getHours();
            const isDayTime = hour > 6 && hour < 20;

            if (code.startsWith('clearsky')) return { description: 'Açık', Icon: isDayTime ? 'fas fa-sun' : 'fas fa-moon' };
            if (code.startsWith('fair')) return { description: 'Az Bulutlu', Icon: isDayTime ? 'fas fa-cloud-sun' : 'fas fa-cloud-moon' };
            if (code.startsWith('partlycloudy')) return { description: 'Parçalı Bulutlu', Icon: 'fas fa-cloud' };
            if (code.startsWith('cloudy')) return { description: 'Bulutlu', Icon: 'fas fa-cloud' };
            if (code.includes('rainshowers')) return { description: 'Sağanak Yağışlı', Icon: 'fas fa-cloud-showers-heavy' };
            if (code.includes('rain')) return { description: 'Yağmurlu', Icon: 'fas fa-cloud-rain' };
            if (code.includes('sleet')) return { description: 'Sulu Kar', Icon: 'fas fa-cloud-meatball' }; // Or use a mix
            if (code.includes('snowshowers')) return { description: 'Kar Sağanağı', Icon: 'fas fa-snowflake' };
            if (code.includes('snow')) return { description: 'Karlı', Icon: 'fas fa-snowflake' };
            if (code.startsWith('fog')) return { description: 'Sisli', Icon: 'fas fa-smog' };
            if (code.includes('thunder')) return { description: 'Gök Gürültülü Fırtına', Icon: 'fas fa-bolt' };
            
            return { description: 'Bilinmiyor', Icon: 'fas fa-question-circle' };
        }

        function showLoading(message, autoHideDelay = 0) {
            loadingMessageEl.textContent = message;
            loadingContainer.style.display = 'flex';
            if (autoHideDelay > 0) {
                setTimeout(() => {
                    // Check if another loading message hasn't superseded this one
                    if (loadingMessageEl.textContent === message) {
                        hideLoading();
                    }
                }, autoHideDelay);
            }
        }

        function hideLoading() {
            loadingContainer.style.display = 'none';
        }

        function updateLoadingMessage(message) {
            if (loadingContainer.style.display !== 'none') {
                loadingMessageEl.textContent = message;
            }
        }
        
        function updateLoadingMessageWithTimeRemaining(lastUpdateTimeMs) {
            if (lastUpdateTimeMs && (Date.now() - lastUpdateTimeMs < SIX_HOURS_MS)) {
                const timeRemaining = SIX_HOURS_MS - (Date.now() - lastUpdateTimeMs);
                // Don't show this if a bulk update is actively running
                if (!isBulkUpdating && loadingContainer.style.display === 'flex' && !loadingMessageEl.textContent.toLowerCase().includes("güncelleniyor")) {
                    showLoading(`Son güncelleme ${formatTimeDifference(Date.now() - lastUpdateTimeMs)} önce yapıldı. Bir sonraki otomatik güncelleme yaklaşık ${formatTimeDifference(timeRemaining)} sonra.`, 3000);
                }
            }
        }


        function showError(message) {
            // Could use a more sophisticated notification system (e.g., a toast)
            alert(message);
            console.error(message);
        }
        
        function formatTimeDifference(ms) {
            if (ms < 0) ms = 0;
            let seconds = Math.floor(ms / 1000);
            let minutes = Math.floor(seconds / 60);
            let hours = Math.floor(minutes / 60);

            seconds %= 60;
            minutes %= 60;

            if (hours > 0) return `${hours} sa ${minutes} dk`;
            if (minutes > 0) return `${minutes} dk ${seconds} sn`;
            return `${seconds} sn`;
        }

        function getHaversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Radius of the Earth in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a =
                Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c; // Distance in km
        }
        
        function updateLastBulkUpdateTimeDisplay() {
            const lastTime = localStorage.getItem('lastBulkUpdateTime_v3');
            if (lastTime) {
                lastBulkUpdateTimeDisplay.textContent = new Date(parseInt(lastTime)).toLocaleString('tr-TR');
            } else {
                lastBulkUpdateTimeDisplay.textContent = "Henüz Yok";
            }
        }

        function updateNextBulkUpdateDisplay(lastUpdateTimeMs) {
            if (lastUpdateTimeMs) {
                const nextUpdateTs = lastUpdateTimeMs + SIX_HOURS_MS;
                const remainingMs = nextUpdateTs - Date.now();
                if (remainingMs > 0) {
                    nextBulkUpdateTimeDisplay.textContent = `${formatTimeDifference(remainingMs)} sonra (${new Date(nextUpdateTs).toLocaleTimeString('tr-TR')})`;
                } else {
                    nextBulkUpdateTimeDisplay.textContent = "Şimdi veya Yakında";
                }
            } else {
                nextBulkUpdateTimeDisplay.textContent = "Belirsiz (İlk güncelleme bekleniyor)";
            }
        }

    </script>
</body>
</html>
